(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{218:function(a,t,e){"use strict";e.r(t);var r=e(0),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"html的盒子模型有哪些构成，盒子模型有哪几种，默认的是哪一种"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html的盒子模型有哪些构成，盒子模型有哪几种，默认的是哪一种","aria-hidden":"true"}},[a._v("#")]),a._v(" HTML的盒子模型有哪些构成，盒子模型有哪几种，默认的是哪一种")]),a._v(" "),e("p",[a._v("content-box")]),a._v(" "),e("h2",{attrs:{id:"盒子模型有没有办法把宽度设置为包含padding的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#盒子模型有没有办法把宽度设置为包含padding的","aria-hidden":"true"}},[a._v("#")]),a._v(" 盒子模型有没有办法把宽度设置为包含padding的")]),a._v(" "),e("p",[a._v("border-box")]),a._v(" "),e("h2",{attrs:{id:"浮动元素有没有什么特征"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浮动元素有没有什么特征","aria-hidden":"true"}},[a._v("#")]),a._v(" 浮动元素有没有什么特征")]),a._v(" "),e("p",[a._v("特征：\n浮动元素会脱离正常的文档流，按照其外边距指定的位置相对于它的上一个块级元素（或父元素）显示\n浮动元素后面的块级元素的内容会向此浮动元素的外边距靠齐，但是边框和背景却忽略浮动元素而向上一个任意非浮动元素靠齐\n浮动元素后面的内联元素会向此浮动元素的外边距靠齐")]),a._v(" "),e("p",[a._v("float造成的影响："),e("br"),a._v("\n1、对其父元素的影响\n对于其父元素来说，元素浮动之后，它脱离当前正常的文档流，所以它也无法撑开其父元素，造成父元素的塌陷\n2、对其兄弟元素（非浮动）的影响"),e("br"),a._v("\n如果兄弟元素为块级元素，该元素会忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过z-index属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素。\n如果如果兄弟元素为内联元素，则元素会环绕浮动元素排列。\n3、对其兄弟元素（浮动）的影响"),e("br"),a._v("\n同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面\n反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下\n4、对子元素的影响"),e("br"),a._v("\n当一个元素浮动时，在没有清除浮动的情况下，它无法撑开其父元素，但它可以让自己的浮动子元素撑开它自身，并且在没有定义具体宽度情况下，使自身的宽度从100%变为自适应（浮动元素display:block）。其高度和宽度均为浮动元素高度和非浮动元素高度之间的最大值。")]),a._v(" "),e("h2",{attrs:{id:"清除浮动的所有方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#清除浮动的所有方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 清除浮动的所有方法")]),a._v(" "),e("ol",[e("li",[a._v("clear:both")]),a._v(" "),e("li",[a._v("overflow:hidden")])]),a._v(" "),e("h2",{attrs:{id:"cookie有哪些特征"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie有哪些特征","aria-hidden":"true"}},[a._v("#")]),a._v(" cookie有哪些特征")]),a._v(" "),e("p",[a._v("cookie可以实现跨页面全局变量"),e("br"),a._v("\ncookie可以跨越同域名下的多个网页，但不能跨越多个域名使用"),e("br"),a._v("\n同一个网站中所有页面共享一套cookie"),e("br"),a._v("\n可以设置有效期限"),e("br"),a._v("\n存储空间4-10KB左右"),e("br"),a._v("\ncookie面临的问题："),e("br"),a._v("\nCSRF(跨站请求伪造)攻击，这个也好解决，很多框架都屏蔽这个问题"),e("br"),a._v("\n有的客户端不支持cookie，需要手动设置，比如小程序\n浏览器对cookie有限制，不能手动设置cookie，对于混合嵌套的开发有问题，比如小程序跳转H5页面，不能携带cookie"),e("br"),a._v("\n浏览器对单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie")]),a._v(" "),e("h2",{attrs:{id:"cookie的其他解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie的其他解决方案","aria-hidden":"true"}},[a._v("#")]),a._v(" cookie的其他解决方案")]),a._v(" "),e("p",[a._v("session 是另一种记录服务器和客户端会话状态的机制"),e("br"),a._v("\nsession 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中")]),a._v(" "),e("h3",{attrs:{id:"cookie-和-session-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie-和-session-的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" Cookie 和 Session 的区别")]),a._v(" "),e("p",[a._v("安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。"),e("br"),a._v("\n存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。"),e("br"),a._v("\n有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。"),e("br"),a._v("\n存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。")]),a._v(" "),e("h3",{attrs:{id:"什么是-jwt"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-jwt","aria-hidden":"true"}},[a._v("#")]),a._v(" 什么是 JWT")]),a._v(" "),e("p",[a._v("JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。"),e("br"),a._v("\n是一种认证授权机制。"),e("br"),a._v("\nJWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。"),e("br"),a._v("\n可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。")]),a._v(" "),e("h3",{attrs:{id:"token-和-jwt-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#token-和-jwt-的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" Token 和 JWT 的区别")]),a._v(" "),e("p",[a._v("Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。"),e("br"),a._v("\nJWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。")]),a._v(" "),e("p",[a._v("session面临的问题："),e("br"),a._v("\n负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享seesion。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。"),e("br"),a._v("\n每个客户端只需存储自己的session          id，但是服务端却需要存储所有用户session      id，对服务器也是一个压力"),e("br"),a._v("\ntoken的意思是“令牌”，是用户身份的验证方式，最简单的token组成：sign(签名，经过加密后的数据)，相当于上文提到的session id。token可以放在header、url中，在每次网络访问都携带，一般是写请求头header中。相比于cookie，你可以认为只是存储的地方参数不同而已。token相比于cookie就是有cookie的功能，没有cookie的限制。比如其他客户端不会限制header的cookie。token是cookie很好替代品。")]),a._v(" "),e("p",[a._v("解决方案"),e("br"),a._v("\n针对上面提到问题，人们想到的办法是用token代替cookie和seesion。一个token怎么替代两个的呢？\n服务端把用户信息加密（token）传给客户端，客户端每次访问都返回token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session id占用存储空间，就很好的解决负载均衡多服务器的问题了")]),a._v(" "),e("h2",{attrs:{id:"localstorage存数据的格式是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#localstorage存数据的格式是什么","aria-hidden":"true"}},[a._v("#")]),a._v(" localstorage存数据的格式是什么")]),a._v(" "),e("p",[a._v("localStorage存储数据的格式都是以字符串的形式来存储的"),e("br"),a._v("\n16怎样将一个数组存入localstorage"),e("br"),a._v("\n17storage有哪些存储方法"),e("br"),a._v("\n读取属性\ngetItem\n18html5的一些新的特性")]),a._v(" "),e("h2",{attrs:{id:"箭头函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 箭头函数")]),a._v(" "),e("p",[a._v("引入箭头函数有两个方面的作用：更简短的函数并且不绑定this")]),a._v(" "),e("p",[a._v("箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj.")]),a._v(" "),e("h2",{attrs:{id:"如果一个页面要做性能优化，从哪方面考察，从哪些地方优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果一个页面要做性能优化，从哪方面考察，从哪些地方优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 如果一个页面要做性能优化，从哪方面考察，从哪些地方优化")]),a._v(" "),e("p",[a._v("https://segmentfault.com/a/1190000010927816")]),a._v(" "),e("h2",{attrs:{id:"请解释原型继承（prototypal-inheritance）的工作原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请解释原型继承（prototypal-inheritance）的工作原理","aria-hidden":"true"}},[a._v("#")]),a._v(" 请解释原型继承（prototypal inheritance）的工作原理")]),a._v(" "),e("p",[a._v("每一个对象都包含一个原型属性，用于关联另一个对象，关联后就能使用那个对象的属性和方法，这就是js的原型式继承。")]),a._v(" "),e("blockquote",[e("p",[a._v("所有 JS 对象都有一个prototype属性，指向它的原型对象。当试图访问一个对象的属性时，")])]),a._v(" "),e("p",[a._v("如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，"),e("br"),a._v("\n直到找到一个名字匹配的属性或到达原型链的末尾。这种行为是在模拟经典的继承，但是与其说是继承，不如说是委托（delegation）。")]),a._v(" "),e("h2",{attrs:{id:"说说你对-amd-和-commonjs-的了解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说说你对-amd-和-commonjs-的了解","aria-hidden":"true"}},[a._v("#")]),a._v(" 说说你对 AMD 和 CommonJS 的了解")]),a._v(" "),e("p",[a._v("它们都是实现模块体系的方式，直到 ES2015 出现之前，JavaScript 一直没有模块体系。CommonJS 是同步的，而 AMD（Asynchronous Module Definition）从全称中可以明显看出是异步的。CommonJS 的设计是为服务器端开发考虑的，而 AMD 支持异步加载模块，更适合浏览器。")]),a._v(" "),e("p",[a._v("(前端模块化：CommonJS, AMD, CMD, ES6)")]),a._v(" "),e("h2",{attrs:{id:"埋点的实现思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#埋点的实现思路","aria-hidden":"true"}},[a._v("#")]),a._v(" 埋点的实现思路")]),a._v(" "),e("blockquote",[e("p",[a._v("代码埋点、可视化埋点和无痕埋点")])]),a._v(" "),e("p",[a._v("如果埋点的事件较多，或者说网页内部交互频繁，可以通过本地存储的方式先缓存上报信息，然后定期上报。")]),a._v(" "),e("h2",{attrs:{id:"文件上传断点、续传"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件上传断点、续传","aria-hidden":"true"}},[a._v("#")]),a._v(" 文件上传断点、续传")]),a._v(" "),e("ol",[e("li",[a._v("把文件按大小1M分割成N份")]),a._v(" "),e("li",[a._v("每次上传时，告诉后台大文件的md5、当前第几份（从0开始）、总共几份")]),a._v(" "),e("li",[a._v("并行上传，前端同时开启5个请求进行传输增加速度")]),a._v(" "),e("li",[a._v("上传失败或出错后，继续上传下一份，把出错的份放在队尾，如果一直出错则中断请求防止死循环")]),a._v(" "),e("li",[a._v("后台接受文件后通过md5进行比对，上次是否接受过此文件，如果接受则跳过，最后进行文件合并出来")])]),a._v(" "),e("h2",{attrs:{id:"vue-react-diff-算法的大概思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-react-diff-算法的大概思路","aria-hidden":"true"}},[a._v("#")]),a._v(" VUE/React diff 算法的大概思路")]),a._v(" "),e("blockquote",[e("p",[a._v("react diff 原理")])]),a._v(" "),e("p",[a._v("react中diff算法实现流程:")]),a._v(" "),e("pre",[e("code",[a._v("DOM结构发生改变-----直接卸载并重新create        \nDOM结构一样-----不会卸载,但是会update变化的内容所有同一层级的子节点.他们都可以通过key来区分-----同时遵循1.2两点   (其实这个key的存在与否只会影响diff算法的复杂度,换言之,你不加key的情况下,diff算法就会以暴力的方式去根据一二的策略更新,但是你加了key,diff算法会引入一些另外的操作)       \n")])]),a._v(" "),e("p",[a._v("把树形结构按照层级分解，只比较同级元素。"),e("br"),a._v("\n给列表结构的每个单元添加唯一的 key     属性，方便比较。\nReact 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）"),e("br"),a._v("\n合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\n选择性子树渲染。"),e("br"),a._v("\n开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。")]),a._v(" "),e("blockquote",[e("p",[a._v("vue中diff算法实现流程：")])]),a._v(" "),e("pre",[e("code",[a._v("1.在内存中构建虚拟dom树     \n2.将内存中虚拟dom树渲染成真实dom结构        \n3.数据改变的时候，将之前的虚拟dom树结合新的数据生成新的虚拟dom树\n")])]),a._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[a._v("将此次生成好的虚拟dom树和上一次的虚拟dom树进行一次比对(diff算法进行比对)，来更新只需要被替换的DOM，而不是全部重绘。在Diff算法中，只平层的比较前后两棵DOM树的节点，没有进行深度的遍历。")])]),a._v(" "),e("pre",[e("code",[a._v("5.会将对比出来的差异进行重新渲染\nvue diff        \n")])]),a._v(" "),e("p",[a._v("当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。")]),a._v(" "),e("h2",{attrs:{id:"虚拟dom算法思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom算法思路","aria-hidden":"true"}},[a._v("#")]),a._v(" 虚拟DOM算法思路")]),a._v(" "),e("blockquote",[e("p",[a._v("用JS对象模拟DOM树")])]),a._v(" "),e("p",[a._v("比较两棵虚拟DOM树的差异\n把差异应用到真正的DOM树上")]),a._v(" "),e("h2",{attrs:{id:"webpack中-loader、plugin-的实现思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack中-loader、plugin-的实现思路","aria-hidden":"true"}},[a._v("#")]),a._v(" webpack中 loader、plugin 的实现思路")]),a._v(" "),e("p",[a._v("Loader: 能把源文件经过转化后输出新的结果\nWebpack通过Plugin机制让其更加灵活，以适应各种应用场景。 在Webpack运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过Webpack提供的API改变输出结果。")]),a._v(" "),e("h2",{attrs:{id:"前端构建工具的、vue-cli、create-react-app-的原理和实现思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端构建工具的、vue-cli、create-react-app-的原理和实现思路","aria-hidden":"true"}},[a._v("#")]),a._v(" 前端构建工具的、vue-cli、create-react-app 的原理和实现思路")]),a._v(" "),e("p",[e("img",{attrs:{src:"https://pic2.zhimg.com/80/v2-b487d3a06dbf5ddf8caab18f13616485_hd.jpg",alt:"vue-cli"}})]),a._v(" "),e("h2",{attrs:{id:"事件委托？原理、好处、应用场景。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件委托？原理、好处、应用场景。","aria-hidden":"true"}},[a._v("#")]),a._v(" 事件委托？原理、好处、应用场景。")]),a._v(" "),e("p",[a._v("事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器。当触发子元素时，事件会冒泡到父元素，监听器就会触发。"),e("br"),a._v("\n这种技术的好处是：\n内存占用减少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。\n无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。")]),a._v(" "),e("h2",{attrs:{id:"vue和react的区别。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue和react的区别。","aria-hidden":"true"}},[a._v("#")]),a._v(" vue和react的区别。")]),a._v(" "),e("p",[a._v("1.react整体的思路就是函数式，所以推崇纯组件，数据不可变，单向数据流.\n而vue是基于可变数据的，支持双向绑定.\n2.vue内置了很多功能，而react做的很少，很多都是由社区来完成的，vue追求的是开发的简单，而react更在乎方式是否正确。")]),a._v(" "),e("h2",{attrs:{id:"vuex的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex的原理","aria-hidden":"true"}},[a._v("#")]),a._v(" VUEX的原理")]),a._v(" "),e("p",[a._v("vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件")]),a._v(" "),e("h2",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包","aria-hidden":"true"}},[a._v("#")]),a._v(" 闭包")]),a._v(" "),e("blockquote",[e("p",[a._v("闭包是函数和声明该函数的词法环境的组合。")])]),a._v(" "),e("p",[a._v("词法作用域中使用的域，是变量在代码中声明的位置所决定的。闭包是即使被外部函数返回，依然可以访问到外部（封闭）函数作用域的函数。"),e("br"),a._v("\n为什么使用闭包？"),e("br"),a._v("\n利用闭包实现数据私有化或模拟私有方法。这个方式也称为模块模式（module pattern）。"),e("br"),a._v("\n部分参数函数（partial applications）柯里化（currying）.")]),a._v(" "),e("h2",{attrs:{id:"匿名函数的典型应用场景是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#匿名函数的典型应用场景是什么","aria-hidden":"true"}},[a._v("#")]),a._v(" 匿名函数的典型应用场景是什么")]),a._v(" "),e("p",[a._v("匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。")]),a._v(" "),e("p",[a._v("(function() {\n// 一些代码。\n})();\n匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。\n当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。"),e("br"),a._v("\n匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。")]),a._v(" "),e("h2",{attrs:{id:"宿主对象（hostbjects）和原生对象（native-objects）的区别是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#宿主对象（hostbjects）和原生对象（native-objects）的区别是什么","aria-hidden":"true"}},[a._v("#")]),a._v(" 宿主对象（hostbjects）和原生对象（native objects）的区别是什么")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("原生对象是由 ECMAScript 规范定义的 JavaScript 内置对象，比如String、Math、RegExp、Object、Function等等。")])]),a._v(" "),e("li",[e("p",[a._v("宿主对象是由运行时环境（浏览器或 Node）提供，比如window、XMLHTTPRequest等等。")])])]),a._v(" "),e("h2",{attrs:{id:"call和-apply有什么区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#call和-apply有什么区别？","aria-hidden":"true"}},[a._v("#")]),a._v(" call和.apply有什么区别？")]),a._v(" "),e("p",[a._v(".call和.apply都用于调用函数，")]),a._v(" "),e("p",[a._v("第一个参数将用作函数内 this 的值。然而，\n.call接受逗号分隔的参数作为后面的参数，而.apply接受一个参数数组作为后面的参数。一个简单的记忆方法是，\n从call中的 C 联想到逗号分隔（comma-separated），从apply中的 A 联想到数组（array）。\nfunction add(a, b) {\nreturn a + b;\n}\nconsole.log(add.call(null, 1, 2)); // 3\nconsole.log(add.apply(null, [1, 2])); // 3")]),a._v(" "),e("h2",{attrs:{id:"功能检测（feature-detection）、功能推断（feature-inference）和使用-ua-字符串之间有什么区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#功能检测（feature-detection）、功能推断（feature-inference）和使用-ua-字符串之间有什么区别？","aria-hidden":"true"}},[a._v("#")]),a._v(" 功能检测（feature detection）、功能推断（feature inference）和使用 UA 字符串之间有什么区别？")]),a._v(" "),e("p",[a._v('功能检测包括确定浏览器是否支持某段代码，以及是否运行不同的代码（取决于它是否执行），以便浏览器始终能够正常运行代码功能，而不会在某些浏览器中出现崩溃和错误。例如：\nif ("geolocation" in navigator) {\n// 可以使用 navigator.geolocation\n} else {\n// 处理 navigator.geolocation 功能缺失\n}\nModernizr是处理功能检测的优秀工具。\n功能推断与功能检测一样，会对功能可用性进行检查，但是在判断通过后，还会使用其他功能，因为它假设其他功能也可用.\nUA 字符串这是一个浏览器报告的字符串，它允许网络协议对等方（network protocol peers）识别请求用户代理的应用类型、操作系统、应用供应商和应用版本。它可以通过navigator.userAgent访问。')]),a._v(" "),e("h2",{attrs:{id:"单页应用有那些优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单页应用有那些优缺点","aria-hidden":"true"}},[a._v("#")]),a._v(" 单页应用有那些优缺点")]),a._v(" "),e("p",[a._v("好处：\n用户感知响应更快，用户切换页面时，不再看到因页面刷新而导致的白屏。"),e("br"),a._v("\n对服务器进行的 HTTP      请求减少，因为对于每个页面加载，不必再次下载相同的资源。"),e("br"),a._v("\n客户端和服务器之间的关注点分离。可以为不同平台（例如手机、聊天机器人、智能手表）建立新的客户端，而无需修改服务器代码。只要 API 没有修改，可以单独修改客户端和服务器上的代码。\n坏处："),e("br"),a._v("\n由于加载了多个页面所需的框架、应用代码和资源，导致初始页面加载时间较长。"),e("br"),a._v("\n服务器还需要进行额外的工作，需要将所有请求路由配置到单个入口点，然后由客户端接管路由。"),e("br"),a._v("\nSPA 依赖于 JavaScript        来呈现内容，但并非所有搜索引擎都在抓取过程中执行 JavaScript，他们可能会在你的页面上看到空的内容。"),e("br"),a._v("\n这无意中损害了应用的搜索引擎优化（SEO）。然而，当你构建应用时，大多数情况下，搜索引擎优化并不是最重要的因素，因为并非所有内容都需要通过搜索引擎进行索引。"),e("br"),a._v("\n为了解决这个问题，可以在服务器端渲染你的应用，或者使用诸如 Prerender 的服务来“在浏览器中呈现你的 javascript，保存静态 HTML，并将其返回给爬虫”。")]),a._v(" "),e("h2",{attrs:{id:"请说明-jsonp-的工作原理，它为什么不是真正的-ajax？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请说明-jsonp-的工作原理，它为什么不是真正的-ajax？","aria-hidden":"true"}},[a._v("#")]),a._v(" 请说明 JSONP 的工作原理，它为什么不是真正的 Ajax？")]),a._v(" "),e("p",[a._v("JSONP（带填充的 JSON）是一种通常用于绕过 Web 浏览器中的跨域限制的方法，因为 Ajax 不允许跨域请求。")]),a._v(" "),e("p",[a._v("JSONP 通过script标签发送跨域请求，通常使用callback查询参数，例如：https://example.com?callback=printData。"),e("br"),a._v("\n然后服务器将数据包装在一个名为printData的函数中并将其返回给客户端。\n"),e("script",[a._v("\nfunction printData(data) {</p>\n<pre><code>console.log( `My name is ${data.name}!` );\n</code></pre>\n<p>}\n")]),a._v(" "),e("script",{attrs:{src:"https://example.com?callback=printData"}}),a._v('\nprintData({ name: "Yang Shun" });\n客户端必须在其全局范围内具有printData函数，并且在收到来自跨域的响应时，该函数将由客户端执行。\nJSONP 可能具有一些安全隐患。由于 JSONP 是纯 JavaScript 实现，它可以完成 JavaScript 所能做的一切，因此需要信任 JSONP 数据的提供者。\n现如今，跨来源资源共享（CORS） 是推荐的主流方式，JSONP 已被视为一种比较 hack 的方式。')]),a._v(" "),e("h2",{attrs:{id:"attribute-和-property-之间有什么区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#attribute-和-property-之间有什么区别？","aria-hidden":"true"}},[a._v("#")]),a._v(' "attribute" 和 "property" 之间有什么区别？')]),a._v(" "),e("p",[a._v("“Attribute” 是在 HTML 中定义的，\n而 “property” 是在 DOM 上定义的。")]),a._v(" "),e("h2",{attrs:{id:"document-中的load事件和domcontentloaded事件之间的区别是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#document-中的load事件和domcontentloaded事件之间的区别是什么？","aria-hidden":"true"}},[a._v("#")]),a._v(" document 中的load事件和DOMContentLoaded事件之间的区别是什么？")]),a._v(" "),e("p",[a._v("当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，而无需等待样式表、图像和子框架的完成加载。")]),a._v(" "),e("p",[a._v("window的load事件仅在 DOM 和所有相关资源全部完成加载后才会触发。")]),a._v(" "),e("h2",{attrs:{id:"什么是-use-strict-？使用它有什么优缺点？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-use-strict-？使用它有什么优缺点？","aria-hidden":"true"}},[a._v("#")]),a._v(' 什么是"use strict"; ？使用它有什么优缺点？')]),a._v(" "),e("p",[a._v("use strict' 是用于对整个脚本或单个函数启用严格模式的语句。严格模式是可选择的一个限制 JavaScript 的变体一种方式 。")]),a._v(" "),e("p",[a._v("优点："),e("br"),a._v("\n无法再意外创建全局变量。"),e("br"),a._v("\n会使引起静默失败（silently fail，即：不报错也没有任何效果）的赋值操抛出异常。"),e("br"),a._v("\n试图删除不可删除的属性时会抛出异常（之前这种操作不会产生任何效果）。"),e("br"),a._v("\n要求函数的参数名唯一。"),e("br"),a._v("\n全局作用域下，this的值为undefined。"),e("br"),a._v("\n捕获了一些常见的编码错误，并抛出异常。"),e("br"),a._v("\n缺点："),e("br"),a._v("\n无法访问function.caller和function.arguments。\n以不同严格模式编写的脚本合并后可能导致问题。")]),a._v(" "),e("h2",{attrs:{id:"什么是事件循环？调用堆栈和任务队列之间有什么区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是事件循环？调用堆栈和任务队列之间有什么区别？","aria-hidden":"true"}},[a._v("#")]),a._v(" 什么是事件循环？调用堆栈和任务队列之间有什么区别？")]),a._v(" "),e("blockquote",[e("p",[a._v("事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。")])]),a._v(" "),e("p",[a._v("如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。")]),a._v(" "),e("h2",{attrs:{id:"let和var的区别。let产生的背景？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#let和var的区别。let产生的背景？","aria-hidden":"true"}},[a._v("#")]),a._v(" let和var的区别。let产生的背景？")]),a._v(" "),e("p",[a._v("用var声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。")]),a._v(" "),e("p",[a._v("let和const是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问。"),e("br"),a._v("\n为什么会添加这个块级作用域，就得了解ES5没有块级作用域时出现的问题。"),e("br"),a._v("\n场景一是内层变量可能会覆盖外层变量。"),e("br"),a._v("\n场景二是在if或者是for循环中声明的变量会泄漏成为全局变量。")]),a._v(" "),e("h2",{attrs:{id:"请阐述块格式化上下文（block-formatting-context）及其工作原理。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请阐述块格式化上下文（block-formatting-context）及其工作原理。","aria-hidden":"true"}},[a._v("#")]),a._v(" 请阐述块格式化上下文（Block Formatting Context）及其工作原理。")]),a._v(" "),e("p",[a._v("块格式上下文（BFC）是 Web 页面的可视化 CSS 渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。\n一个 HTML 盒（Box）满足以下任意一条，会创建块格式化上下文：\nfloat的值不是none.\nposition的值不是static或relative.\ndisplay的值是table-cell、table-caption、inline-block、flex、或inline-flex。\noverflow的值不是visible。\n在 BFC 中，每个盒的左外边缘都与其包含的块的左边缘相接。\n两个相邻的块级盒在垂直方向上的边距会发生合并（collapse）。更多内容请参考边距合并（margin collapsing）。")]),a._v(" "),e("h2",{attrs:{id:"有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）","aria-hidden":"true"}},[a._v("#")]),a._v(" 有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）")]),a._v(" "),e("p",[a._v("visibility: hidden：元素仍然在页面流中，并占用空间。"),e("br"),a._v("\nwidth: 0; height:        0：使元素不占用屏幕上的任何空间，导致不显示它。\nposition: absolute; left: -99999px： 将它置于屏幕之外。"),e("br"),a._v("\ntext-indent: -9999px：这只适用于block元素中的文本。\nMetadata： 例如通过使用 Schema.org，RDF 和 JSON-LD。"),e("br"),a._v("\nWAI-ARIA：如何增加网页可访问性的 W3C 技术规范。")]),a._v(" "),e("h2",{attrs:{id:"使用-css-预处理的优缺点分别是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-css-预处理的优缺点分别是什么","aria-hidden":"true"}},[a._v("#")]),a._v(" 使用 CSS 预处理的优缺点分别是什么")]),a._v(" "),e("p",[a._v("优点：")]),a._v(" "),e("p",[a._v("提高 CSS 可维护性。"),e("br"),a._v("\n易于编写嵌套选择器。"),e("br"),a._v("\n引入变量，增添主题功能。可以在不同的项目中共享主题文件。"),e("br"),a._v("\n通过混合（Mixins）生成重复的 CSS。"),e("br"),a._v("\n将代码分割成多个文件。不进行预处理的         CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。"),e("br"),a._v("\n缺点："),e("br"),a._v("\n需要预处理工具。"),e("br"),a._v("\n重新编译的时间可能会很慢。")]),a._v(" "),e("h2",{attrs:{id:"什么情况下，用translate-而不用绝对定位？什么时候，情况相反"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下，用translate-而不用绝对定位？什么时候，情况相反","aria-hidden":"true"}},[a._v("#")]),a._v(" 什么情况下，用translate()而不用绝对定位？什么时候，情况相反")]),a._v(" "),e("p",[a._v("translate()是transform的一个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），"),e("br"),a._v("\n只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。transform使浏览器为元素创建一个 GPU 图层，"),e("br"),a._v("\n但改变绝对定位会使用到 CPU。         因此translate()更高效，可以缩短平滑动画的绘制时间。"),e("br"),a._v("\n当使用translate()时，元素仍然占据其原始空间（有点像position：relative），这与改变绝对定位不同。")]),a._v(" "),e("h2",{attrs:{id:"请简述javascript中的this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请简述javascript中的this","aria-hidden":"true"}},[a._v("#")]),a._v(" 请简述JavaScript中的this")]),a._v(" "),e("p",[a._v("粗略地讲，函数的调用方式决定了this的值。this取值符合以下规则：")]),a._v(" "),e("p",[a._v("在调用函数时使用new关键字，函数内的this是一个全新的对象。"),e("br"),a._v("\n如果apply、call或bind方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。"),e("br"),a._v("\n当函数作为对象里的方法被调用时，函数内的this是调用该函数的对象。比如当obj.method()被调用时，函数内的 this 将绑定到obj对象。"),e("br"),a._v("\n如果调用函数不符合上述规则，那么this的值指向全局对象（global object）。浏览器环境下this的值指向window对象，但是在严格模式下('use strict')，this的值为undefined。"),e("br"),a._v("\n如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定this的值。"),e("br"),a._v("\n如果该函数是 ES2015      中的箭头函数，将忽略上面的所有规则，this被设置为它被创建时的上下文。")]),a._v(" "),e("h2",{attrs:{id:"在浏览器中，一个页面从输入url到加载完成，都有哪些步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在浏览器中，一个页面从输入url到加载完成，都有哪些步骤","aria-hidden":"true"}},[a._v("#")]),a._v(" 在浏览器中，一个页面从输入URL到加载完成，都有哪些步骤")]),a._v(" "),e("ol",[e("li",[a._v("域名解析")]),a._v(" "),e("li",[a._v("建立TCP连接，浏览器与服务器经过3次握手后建立连接")]),a._v(" "),e("li",[a._v("浏览器发起HTTP气球，获取资源/*-")]),a._v(" "),e("li",[a._v("服务器响应HTTP气球")]),a._v(" "),e("li",[a._v("浏览器渲染")])]),a._v(" "),e("h2",{attrs:{id:"http1-1-有哪些不足"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http1-1-有哪些不足","aria-hidden":"true"}},[a._v("#")]),a._v(" HTTP1.1 有哪些不足")]),a._v(" "),e("ol",[e("li",[a._v("出现队首阻塞问题")]),a._v(" "),e("li",[a._v("响应不分轻重缓急，只会先来后到")]),a._v(" "),e("li",[a._v("并行需要建立多个TCP")]),a._v(" "),e("li",[a._v("只能被动等待客户端发起请求")]),a._v(" "),e("li",[a._v("HTTP是无状态的，每次请求和响应都会携带大量冗余信息")])]),a._v(" "),e("h2",{attrs:{id:"用new-运算符创建对象时，具体的创建过程有哪几步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用new-运算符创建对象时，具体的创建过程有哪几步","aria-hidden":"true"}},[a._v("#")]),a._v(" 用new 运算符创建对象时，具体的创建过程有哪几步")]),a._v(" "),e("ol",[e("li",[a._v("一个新对象被创建，它继承自构造函数的原型")]),a._v(" "),e("li",[a._v("将指定的参数传递给构造函数")]),a._v(" "),e("li",[a._v("将执行上下文（this）绑定到新创建的对象中")]),a._v(" "),e("li",[a._v("如果构造函数有返回值，那么返回值将取代第一步中新创建的对象")])]),a._v(" "),e("h2",{attrs:{id:"isprototypeof方法与instanceof-运算符有哪些区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#isprototypeof方法与instanceof-运算符有哪些区别","aria-hidden":"true"}},[a._v("#")]),a._v(" isPrototypeOf方法与instanceof 运算符有哪些区别")]),a._v(" "),e("p",[a._v("isPrototypeOf 用于检测调用此方法对象是否存在于指定对象的原型链中，`\n而instanceof用于检测构造函数的原型是否存在于指定对象的原型链")]),a._v(" "),e("h2",{attrs:{id:"请介绍一下节流函数和防抖函数，简单实现节流函数和防抖函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请介绍一下节流函数和防抖函数，简单实现节流函数和防抖函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 请介绍一下节流函数和防抖函数，简单实现节流函数和防抖函数")]),a._v(" "),e("p",[a._v("他们都是可以防止一个函数被无意义的高频率调用\n区别在于:\n函数节流：是确保函数特定的时间内至多执行一次。\n函数防抖：是函数在特定的时间内不被再调用后执行。")]),a._v(" "),e("h2",{attrs:{id:"请介绍一下回流（reflow）与重绘（repaint）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请介绍一下回流（reflow）与重绘（repaint）","aria-hidden":"true"}},[a._v("#")]),a._v(" 请介绍一下回流（Reflow）与重绘（Repaint）")]),a._v(" "),e("p",[a._v("回流（Reflow）：render       树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。")]),a._v(" "),e("p",[a._v("重绘：render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响 render 树重新布局的，比如修改字体颜色。"),e("br"),a._v("\n注意：回流一定会触发重绘，而重绘不一定会回流。")]),a._v(" "),e("h2",{attrs:{id:"请描述一下什么是执行栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请描述一下什么是执行栈","aria-hidden":"true"}},[a._v("#")]),a._v(" 请描述一下什么是执行栈")]),a._v(" "),e("p",[a._v("可以把执行栈认为是一个存储函数调用的栈结构，它遵从先进后出的原则。")]),a._v(" "),e("h2",{attrs:{id:"vue通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue通信","aria-hidden":"true"}},[a._v("#")]),a._v(" Vue通信")]),a._v(" "),e("p",[a._v("1.props和$emit")]),a._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[a._v("EventBus(基本不用)")])]),a._v(" "),e("p",[a._v("3.vuex")]),a._v(" "),e("p",[e("a",{attrs:{href:"http://react-china.org/t/topic/33558",target:"_blank",rel:"noopener noreferrer"}},[a._v("react"),e("OutboundLink")],1),e("br"),a._v(" "),e("a",{attrs:{href:"https://github.com/sudheerj/reactjs-interview-questions",target:"_blank",rel:"noopener noreferrer"}},[a._v("react-github"),e("OutboundLink")],1)]),a._v(" "),e("h2",{attrs:{id:"斐波那契数列？怎么优化？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#斐波那契数列？怎么优化？","aria-hidden":"true"}},[a._v("#")]),a._v(" 斐波那契数列？怎么优化？")]),a._v(" "),e("p",[a._v("每一项是前两项之和, 递归结束条件是f[1]=1，f[2]=1"),e("br"),a._v("\n1，2，3，5，8，13，21，34"),e("br"),a._v("\nF(n)=F(n-1)+F(n-2)"),e("br"),a._v("\n方法1（递归）"),e("br"),a._v("\n时间复杂度：O（N2），空间复杂度：O（N）"),e("br"),a._v("\n方法2（循环）"),e("br"),a._v("\n时间复杂度：O（N），时间复杂度：O（1）")]),a._v(" "),e("h2",{attrs:{id:"node主要用来解决什么问题，node做bff的优点是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node主要用来解决什么问题，node做bff的优点是什么","aria-hidden":"true"}},[a._v("#")]),a._v(" node主要用来解决什么问题，node做BFF的优点是什么")]),a._v(" "),e("p",[a._v("node中间层解决SEO, 首屏渲染, 前后端分离,\n服务器之间内网请求接口速度比请求快。\nnode: 高并发，异步IO\n每个Node.js进程可以支持超过12万活跃的连接，每个连接消耗大约2K的内存"),e("br"),a._v("\n加了中间层一方面是为了不让前台直接性的去访问主要逻辑接口，\nnode中间层可以过滤、合并请求，这样来减少主要数据接口服务器的性能消耗 。")]),a._v(" "),e("h2",{attrs:{id:"对项目监控这块有什么了解吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对项目监控这块有什么了解吗","aria-hidden":"true"}},[a._v("#")]),a._v(" 对项目监控这块有什么了解吗")]),a._v(" "),e("p",[a._v("一个监控系统，大致可以分为四个阶段：日志采集、日志存储、统计与分析、报告和警告。")]),a._v(" "),e("h2",{attrs:{id:"对微服务有了解吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对微服务有了解吗","aria-hidden":"true"}},[a._v("#")]),a._v(" 对微服务有了解吗")]),a._v(" "),e("p",[a._v("微服务的目的是有效的拆分应用，实现敏捷开发和部署"),e("br"),a._v("\n使用 HTTP 服务器的路由来重定向多个应用"),e("br"),a._v("\n在不同的框架之上设计通讯、加载机制，诸如 Mooa 和 Single-SPA"),e("br"),a._v("\n通过组合多个独立应用、组件来构建一个单体应用"),e("br"),a._v("\niFrame。使用 iFrame 及自定义消息传递机制"),e("br"),a._v("\n使用纯 Web Components 构建应用"),e("br"),a._v("\n结合 Web Components 构建")]),a._v(" "),e("h2",{attrs:{id:"restful接口架构的优缺点-restful接口架构会导致什么安全问题，具体怎么解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#restful接口架构的优缺点-restful接口架构会导致什么安全问题，具体怎么解决","aria-hidden":"true"}},[a._v("#")]),a._v(" restful接口架构的优缺点, restful接口架构会导致什么安全问题，具体怎么解决")]),a._v(" "),e("p",[a._v("RESTful架构优点：\n前后端分离，减少流量"),e("br"),a._v("\n安全问题集中在接口上，由于接受json格式，防止了注入型等安全问题"),e("br"),a._v("\n前端无关化，后端只负责数据处理，前端表现方式可以是任何前端语言（android，ios, html5）"),e("br"),a._v("\n前端和后端人员更加专注于各自开发，只需接口文档便可完成前后端交互，无需过多相互了解"),e("br"),a._v("\n服务器性能优化：由于前端是静态页面，通过nginx便可获取，服务器主要压力放在了接口上"),e("br"),a._v("\nRESTful优点\nURL具有很强可读性的，具有自描述性\n可提供OpenAPI，便于第三方系统集成，提高互操作性；\nRESTful的缺点\n请求路径将表内关系完全暴露，响应结果将表结构暴露")]),a._v(" "),e("h2",{attrs:{id:"webpack性能优化你知道哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack性能优化你知道哪些","aria-hidden":"true"}},[a._v("#")]),a._v(" Webpack性能优化你知道哪些")]),a._v(" "),e("ol",[e("li",[a._v("优化Loader的文件搜索范围")]),a._v(" "),e("li",[a._v("把Babel编译过的文件缓存起来 loader: 'babel-loader?cacheDirectory=ture'")]),a._v(" "),e("li",[a._v("HappyPack可以将Loader的同步执行转换为并行的")]),a._v(" "),e("li",[a._v("DllPlugin可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案.")]),a._v(" "),e("li",[a._v("Scope Hoisting会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。")]),a._v(" "),e("li",[a._v("Tree Shaking 可以实现删除项目中未被引用的代码")])]),a._v(" "),e("h2",{attrs:{id:"如何设计一个组件？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何设计一个组件？","aria-hidden":"true"}},[a._v("#")]),a._v(" 如何设计一个组件？")]),a._v(" "),e("p",[a._v('组件聚合原则告诉我们设计组件时要考虑的原则，以及如何根据项目的开发时间和成熟度对这些原则进行权衡。组件耦合考虑的是如何管理组件之间的依赖关系，减小组件之间的耦合，组件依赖要考虑的问题。从组件聚合和组件耦合全面分析，可以设计出"高内聚、低耦合"的组件。')]),a._v(" "),e("p",[a._v("适用单一职责原则\n适用开放封闭原则\n追求短小精悍\n避免太多参数\n缩小信赖范围和向稳定方向信赖"),e("br"),a._v("\n追求无副作用\n追求引用透明\n避免暴露组件内部实现\n避免直接操作DOM\n入口处检查参数的有效性，出口处检查返回的正确性\n充分隔离变化的部分"),e("br"),a._v("\n组件和数据分享，信赖一致性的数据结构")]),a._v(" "),e("h2",{attrs:{id:"code-split-怎么做？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#code-split-怎么做？","aria-hidden":"true"}},[a._v("#")]),a._v(" code split 怎么做？")]),a._v(" "),e("p",[a._v("主要有 2 种方式：\n分离业务代码和第三方库（ vendor ）"),e("br"),a._v("\n按需加载（利用 import() 语法）")]),a._v(" "),e("h2",{attrs:{id:"什么是treeshaking？注意些什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是treeshaking？注意些什么？","aria-hidden":"true"}},[a._v("#")]),a._v(" 什么是treeshaking？注意些什么？")]),a._v(" "),e("p",[a._v("Tree-shaking的本质是消除无用的js代码")]),a._v(" "),e("h2",{attrs:{id:"一像素问题怎么解决？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一像素问题怎么解决？","aria-hidden":"true"}},[a._v("#")]),a._v(" 一像素问题怎么解决？")]),a._v(" "),e("p",[a._v("由于分辨率 DPI 的差异，高清手机屏上的 1px 实际上是由 2×2 个像素点来渲染，有的屏幕甚至用到了 3×3 个像素点\n所以在实际的代码实现中，设置1px的边框，会渲染成2px.")]),a._v(" "),e("ol",[e("li",[a._v("使用transform： scale +媒体查询")]),a._v(" "),e("li",[a._v("直接rem设置")])]),a._v(" "),e("h2",{attrs:{id:"jsbridge原理是什么？如何设计一个jsbridge？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jsbridge原理是什么？如何设计一个jsbridge？","aria-hidden":"true"}},[a._v("#")]),a._v(" JSBridge原理是什么？如何设计一个JSBridge？")]),a._v(" "),e("h2",{attrs:{id:"离线包怎么设计？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#离线包怎么设计？","aria-hidden":"true"}},[a._v("#")]),a._v(" 离线包怎么设计？")]),a._v(" "),e("h2",{attrs:{id:"hybrid-h5开发需要注意些什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hybrid-h5开发需要注意些什么？","aria-hidden":"true"}},[a._v("#")]),a._v(" Hybrid  H5开发需要注意些什么？")]),a._v(" "),e("p",[a._v("WebView内存泄漏")]),a._v(" "),e("h2",{attrs:{id:"webview的缓存机制是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webview的缓存机制是什么？","aria-hidden":"true"}},[a._v("#")]),a._v(" Webview的缓存机制是什么？")]),a._v(" "),e("p",[a._v("WebView中存在着两种缓存：网页数据缓存（存储打开过的页面及资源）、H5缓存（cache manifest 文件。这个文件中列出了所有需要在离线状态下使用的资源，浏览器会把这些资源缓存到本地）。")]),a._v(" "),e("h2",{attrs:{id:"有哪些监控网页卡顿的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有哪些监控网页卡顿的方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 有哪些监控网页卡顿的方法")]),a._v(" "),e("p",[a._v("网页内容在不断变化之中，网页的 FPS 是指浏览器在渲染这些变化时的帧率。"),e("br"),a._v("\n帧率越高，用户感觉网页越流畅，反之则会感觉卡顿。"),e("br"),a._v("\n每秒钟计算一次网页的 FPS 值，获得一列数据，然后分析。"),e("br"),a._v("\n通俗地解释就是，通过 requestAnimationFrame API 来定时执行一些 JS 代码，"),e("br"),a._v("\n如果浏览器卡顿，无法很好地保证渲染的频率，1s 中 frame 无法达到 60 帧，即可间接地反映浏览器的渲染帧率。")]),a._v(" "),e("h2",{attrs:{id:"如果需要手动写动画，你认为最小时间间隔是多久，为什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果需要手动写动画，你认为最小时间间隔是多久，为什么？","aria-hidden":"true"}},[a._v("#")]),a._v(" 如果需要手动写动画，你认为最小时间间隔是多久，为什么？")]),a._v(" "),e("p",[a._v("显示器默认频率是60HZ，即1秒刷新60次，故最小时间间隔是 1000/60 = 16.7毫秒")]),a._v(" "),e("h2",{attrs:{id:"什么是cookie-隔离"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是cookie-隔离","aria-hidden":"true"}},[a._v("#")]),a._v(" 什么是Cookie 隔离")]),a._v(" "),e("p",[a._v("若静态文件位于主域名下，请求静态文件时会携带cookie到服务器，浪费流量，故需隔离。"),e("br"),a._v("\n由于cookie有域的限制，不能跨域提交请求，故将静态文件置于非主要域名下，请求静态文件时便不会携带cookie数据。如此可降低请求头大小和请求时间，以便达到降低整体请求耗时的目的。")]),a._v(" "),e("h2",{attrs:{id:"chrome-打开一个页面需要启动多少进程？分别有哪些进程？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#chrome-打开一个页面需要启动多少进程？分别有哪些进程？","aria-hidden":"true"}},[a._v("#")]),a._v(" Chrome 打开一个页面需要启动多少进程？分别有哪些进程？")]),a._v(" "),e("p",[a._v("打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；"),e("br"),a._v("\n最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。")]),a._v(" "),e("p",[a._v("浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。")]),a._v(" "),e("p",[a._v("渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。")]),a._v(" "),e("p",[a._v("GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。")]),a._v(" "),e("p",[a._v("网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。")]),a._v(" "),e("p",[a._v("插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。")]),a._v(" "),e("h2",{attrs:{id:"promise-和-callback-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-和-callback-有什么区别","aria-hidden":"true"}},[a._v("#")]),a._v(" promise 和 callback 有什么区别")]),a._v(" "),e("p",[a._v("Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件更合理")]),a._v(" "),e("p",[a._v("Promise可以用来避免异步操作函数里的嵌套回调问题，因为解决异步最直接的方法是回调嵌套，将后一个的操作放在前一个操作的异步回调里，但如果操作多了，就会有很多层的嵌套。"),e("br"),a._v("\n使用 Promise 对象，可以十分方便的摆脱层层嵌套的异步操作回调函数，而以同步操作的流程书写代码"),e("br"),a._v("\nPromise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。即错误总会被下一个catch语句捕获")]),a._v(" "),e("h2",{attrs:{id:"介绍暂时性死区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍暂时性死区","aria-hidden":"true"}},[a._v("#")]),a._v(" 介绍暂时性死区")]),a._v(" "),e("p",[a._v("在代码块内，使用let命令声明变量之前，该变量都是不可用的。"),e("br"),a._v("\n这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。")]),a._v(" "),e("h2",{attrs:{id:"node-面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-面试题","aria-hidden":"true"}},[a._v("#")]),a._v(" Node 面试题")]),a._v(" "),e("h2",{attrs:{id:"严格路由和不严格路由有什么区别strict-严格路由，例如-foo-和-foo-，默认false关闭。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#严格路由和不严格路由有什么区别strict-严格路由，例如-foo-和-foo-，默认false关闭。","aria-hidden":"true"}},[a._v("#")]),a._v(" 严格路由和不严格路由有什么区别"),e("br"),a._v("\nstrict 严格路由，例如 /foo 和 /foo/ ，默认false关闭。")]),a._v(" "),e("h2",{attrs:{id:"如何设置路由不敏感或严格路由casesensitive-truestrict-true"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何设置路由不敏感或严格路由casesensitive-truestrict-true","aria-hidden":"true"}},[a._v("#")]),a._v(" 如何设置路由不敏感或严格路由"),e("br"),a._v("\ncaseSensitive:true\nstrict:true")]),a._v(" "),e("h2",{attrs:{id:"什么是lazy-router以及为什么要lazy-router生成默认路由对象。无法在默认配置中添加基本路由器，因为可能在运行之后设置的应用程序设置。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是lazy-router以及为什么要lazy-router生成默认路由对象。无法在默认配置中添加基本路由器，因为可能在运行之后设置的应用程序设置。","aria-hidden":"true"}},[a._v("#")]),a._v(" 什么是lazy router以及为什么要lazy router"),e("br"),a._v("\n生成默认路由对象。\n无法在默认配置中添加基本路由器，因为可能在运行之后设置的应用程序设置。")]),a._v(" "),e("h2",{attrs:{id:"trust-proxy什么用req-ip获取到的ip将是实际客户端的ip否则，获取到的是代理服务器的ip"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#trust-proxy什么用req-ip获取到的ip将是实际客户端的ip否则，获取到的是代理服务器的ip","aria-hidden":"true"}},[a._v("#")]),a._v(" trust proxy什么用\nreq.ip获取到的ip将是实际客户端的ip\n否则，获取到的是代理服务器的ip.")]),a._v(" "),e("h2",{attrs:{id:"etag-weak-和strong有什么区别strong-要完完全全一样weak-页面内容一样，只是时间戳不一样可以回一个一样的etag。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag-weak-和strong有什么区别strong-要完完全全一样weak-页面内容一样，只是时间戳不一样可以回一个一样的etag。","aria-hidden":"true"}},[a._v("#")]),a._v(" Etag weak 和strong有什么区别\nstrong 要完完全全一样\nweak 页面内容一样，只是时间戳不一样可以回一个一样的etag。")]),a._v(" "),e("h2",{attrs:{id:"app-all和app-use的区别及性能差异all-执行完整匹配-use-只匹配前缀-，all是路由中指代所有的请求方式，use是中间件。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#app-all和app-use的区别及性能差异all-执行完整匹配-use-只匹配前缀-，all是路由中指代所有的请求方式，use是中间件。","aria-hidden":"true"}},[a._v("#")]),a._v(" app.all和app.use的区别及性能差异"),e("br"),a._v("\nall 执行完整匹配, use 只匹配前缀 ，\nall是路由中指代所有的请求方式，use是中间件。")]),a._v(" "),e("h2",{attrs:{id:"如何捕捉next-err-传递的错误express中内置了一个错误处理程序。如果请求内的同步代码抛出异常或调用next-err-，那么-express-会将当前请求视为处于错误状态，并跳过所有剩余的非错误处理路由和中间件函数，最后被内置的错误处理程序处理。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何捕捉next-err-传递的错误express中内置了一个错误处理程序。如果请求内的同步代码抛出异常或调用next-err-，那么-express-会将当前请求视为处于错误状态，并跳过所有剩余的非错误处理路由和中间件函数，最后被内置的错误处理程序处理。","aria-hidden":"true"}},[a._v("#")]),a._v(" 如何捕捉next(err)传递的错误"),e("br"),a._v("\nexpress中内置了一个错误处理程序。如果请求内的同步代码抛出异常或调用next(err)，那么 Express 会将当前请求视为处于错误状态，并跳过所有剩余的非错误处理路由和中间件函数，最后被内置的错误处理程序处理。")]),a._v(" "),e("h2",{attrs:{id:"路由function内部的错误是在哪个环节捕捉的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由function内部的错误是在哪个环节捕捉的","aria-hidden":"true"}},[a._v("#")]),a._v(" 路由function内部的错误是在哪个环节捕捉的")]),a._v(" "),e("h2",{attrs:{id:"node-js为什么处理异步io快-利用事件队列，不用等待io完成，在非阻塞io返回之前，node主线程可以用来处理其他事物，此时性能提升非常明显。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-js为什么处理异步io快-利用事件队列，不用等待io完成，在非阻塞io返回之前，node主线程可以用来处理其他事物，此时性能提升非常明显。","aria-hidden":"true"}},[a._v("#")]),a._v(" Node.js为什么处理异步IO快?"),e("br"),a._v("\n利用事件队列，不用等待IO完成，在非阻塞IO返回之前，node主线程可以用来处理其他事物，此时性能提升非常明显。")]),a._v(" "),e("h2",{attrs:{id:"node中的错误怎么捕获？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node中的错误怎么捕获？","aria-hidden":"true"}},[a._v("#")]),a._v(" Node中的错误怎么捕获？")]),a._v(" "),e("ol",[e("li",[a._v("使用uncaughtExprection去捕获异常")])]),a._v(" "),e("p",[a._v('process.on("uncaughtExpection", function(err){')]),a._v(" "),e("pre",[e("code",[a._v("  console.log(err)         \n")])]),a._v(" "),e("p",[a._v("})")]),a._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[a._v("用try-catch在回调函数前捕获异常")]),a._v(" "),e("li",[a._v("用框架去包住，捕获异常")])]),a._v(" "),e("p",[a._v("// error handler\napp.use(function(err, req, res, next) {")]),a._v(" "),e("pre",[e("code",[a._v("// set locals, only providing error in development\nres.locals.message = err.message;\nres.locals.error = req.app.get('env') === 'development' ? err : {};\n\n// render the error page\nres.status(err.status || 500);\nres.render('error');\n")])]),a._v(" "),e("h2",{attrs:{id:""}},[e("a",{staticClass:"header-anchor",attrs:{href:"#","aria-hidden":"true"}},[a._v("#")]),a._v(" });")]),a._v(" "),e("h2",{attrs:{id:"如果在回调函数中如何捕获异常呢？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果在回调函数中如何捕获异常呢？","aria-hidden":"true"}},[a._v("#")]),a._v(" 如果在回调函数中如何捕获异常呢？")]),a._v(" "),e("h2",{attrs:{id:"如果是回调函数中捕获异常怎么做？用domain去捕获，domian捕获会抛出500错误，但是domain捕获有一个问题，会丢失栈信息，无法保证程序健康进行，所以要结束进程，在回调函数中process-exit-1-，然后用node的server-close方法再去释放，server-close连接释放后自动结束进程，所以不用在server-close中去结束进程process-exit-1-uncaughtexpection捕获异常的的原理就是：uncaughtexpection事件存在回调函数process-on-uncaughtexpection-callback-时node不会强制结束进程，这样可弥补domain丢失stack的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果是回调函数中捕获异常怎么做？用domain去捕获，domian捕获会抛出500错误，但是domain捕获有一个问题，会丢失栈信息，无法保证程序健康进行，所以要结束进程，在回调函数中process-exit-1-，然后用node的server-close方法再去释放，server-close连接释放后自动结束进程，所以不用在server-close中去结束进程process-exit-1-uncaughtexpection捕获异常的的原理就是：uncaughtexpection事件存在回调函数process-on-uncaughtexpection-callback-时node不会强制结束进程，这样可弥补domain丢失stack的问题","aria-hidden":"true"}},[a._v("#")]),a._v(' 如果是回调函数中捕获异常怎么做？用domain去捕获，domian捕获会抛出500错误，但是domain捕获有一个问题，会丢失栈信息，无法保证程序健康进行，所以要结束进程，在回调函数中process.exit(1)，然后用node的server.close方法再去释放，server.close连接释放后自动结束进程，所以不用在server.close中去结束进程process.exit(1)\nuncaughtExpection捕获异常的的原理就是：uncaughtExpection事件存在回调函数process.on("uncaughtExpection", callback)时node不会强制结束进程，这样可弥补domain丢失stack的问题')]),a._v(" "),e("h2",{attrs:{id:"node中遇到错误，进程退出了怎么办？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node中遇到错误，进程退出了怎么办？","aria-hidden":"true"}},[a._v("#")]),a._v(" Node中遇到错误，进程退出了怎么办？")]),a._v(" "),e("ol",[e("li",[a._v("捕获uncaughtException")]),a._v(" "),e("li",[a._v("使用守护进程\npm2 和 forever ，它们都可以实现进程守护，底层也都是 child_process 模块和 cluster 模块 实现的。"),e("br"),a._v("\nRPC 简单的理解是一个节点请求另一个节点提供的服务"),e("br"),a._v("\nRPC 的全称是 Remote Procedure Call 是一种进程间通信方式。"),e("br"),a._v("\n它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。"),e("br"),a._v("\n即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。"),e("br"),a._v("\n比如两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在一个内存空间，不能直接调用，这时候需要通过就可以应用RPC框架的实现来解决。")])]),a._v(" "),e("h2",{attrs:{id:"promise的错误如何统一捕获？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise的错误如何统一捕获？","aria-hidden":"true"}},[a._v("#")]),a._v(" Promise的错误如何统一捕获？")]),a._v(" "),e("p",[a._v("错误捕获装饰器尝试")]),a._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("tryCatch")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("msg")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("target"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" descriptor")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" original "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" descriptor"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("value\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("typeof")]),a._v(" original "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("===")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'function'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        descriptor"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("value")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("async")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v("args")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("try")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" result "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("await")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("original")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("apply")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" args"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n                "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" result\n            "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("catch")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                message"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("error")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("e"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("message "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("||")]),a._v(" msg "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("||")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'出错了!请稍后重试'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n            "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" descriptor\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br")])]),e("p",[a._v("Promise中的ajax 可以try catch 到么？")]),a._v(" "),e("h2",{attrs:{id:"node-的cluster模式是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node-的cluster模式是什么？","aria-hidden":"true"}},[a._v("#")]),a._v(" Node 的Cluster模式是什么？")]),a._v(" "),e("h2",{attrs:{id:"cluster是一个nodejs内置的模块，用于nodejs多核处理-工作原理集群模块会创建一个master主线程，然后复制任意多份程序并启动，这叫做工作线程。工作线程通过-ipc-频道进行通信并且使用了-round-robin-algorithm-算法进行工作调度以此实现负载均衡。round-robin调度策略主要是master主线程负责接收所有的连接并派发给下面的各个工作线程。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cluster是一个nodejs内置的模块，用于nodejs多核处理-工作原理集群模块会创建一个master主线程，然后复制任意多份程序并启动，这叫做工作线程。工作线程通过-ipc-频道进行通信并且使用了-round-robin-algorithm-算法进行工作调度以此实现负载均衡。round-robin调度策略主要是master主线程负责接收所有的连接并派发给下面的各个工作线程。","aria-hidden":"true"}},[a._v("#")]),a._v(" cluster是一个nodejs内置的模块，用于nodejs多核处理."),e("br"),a._v("\n工作原理\n集群模块会创建一个master主线程，然后复制任意多份程序并启动，这叫做工作线程。\n工作线程通过 IPC 频道进行通信并且使用了 Round-robin algorithm 算法进行工作调度以此实现负载均衡。\nRound-robin调度策略主要是master主线程负责接收所有的连接并派发给下面的各个工作线程。")]),a._v(" "),e("h2",{attrs:{id:"node中的进程和线程什么区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node中的进程和线程什么区别？","aria-hidden":"true"}},[a._v("#")]),a._v(" Node中的进程和线程什么区别？")]),a._v(" "),e("p",[a._v("单线程就是一个进程只开一个线程"),e("br"),a._v("\n进程是线程的容器"),e("br"),a._v("\n调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位"),e("br"),a._v("\n拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源")]),a._v(" "),e("h2",{attrs:{id:"node中如何创建一个进程？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node中如何创建一个进程？","aria-hidden":"true"}},[a._v("#")]),a._v(" Node中如何创建一个进程？")]),a._v(" "),e("h2",{attrs:{id:"node的多个进程如何通信？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node的多个进程如何通信？","aria-hidden":"true"}},[a._v("#")]),a._v(" Node的多个进程如何通信？")]),a._v(" "),e("p",[a._v("使用共享内存，信号量。这种方式可以通过 child_process 模块实现。"),e("br"),a._v("\n使用套接。这种方式可以使用 net，http，websocket 模块实现，还可以使用 socket.io 来实现（推荐）。"),e("br"),a._v("\n使用共享文件。这种方式通过监听文件的变化来实现，不过效率不理想（不推荐）。"),e("br"),a._v("\n使用订阅发布，响应式数据库。通过 Redis 这些数据库，并利用它们的特性进行多进程通信。")]),a._v(" "),e("h2",{attrs:{id:"如何监控node？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何监控node？","aria-hidden":"true"}},[a._v("#")]),a._v(" 如何监控Node？")]),a._v(" "),e("p",[a._v("node-monitor"),e("br"),a._v("\nShell脚本将定期向节点服务器插件询问测量数据。\n如果节点服务器尚未启动或关闭，则脚本会将相应的信息发送到monitis（monitor起了一个服务）。\n随着Node服务器可用，测量值将被捕获并发送到monitis。\nnode-memwatch")]),a._v(" "),e("h2",{attrs:{id:"node中的日志如何串行保证？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node中的日志如何串行保证？","aria-hidden":"true"}},[a._v("#")]),a._v(" Node中的日志如何串行保证？")]),a._v(" "),e("p",[a._v("保存函数执行顺序，然后执行数组中下一个函数的函数")]),a._v(" "),e("h2",{attrs:{id:"node中的事件循环是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#node中的事件循环是什么？","aria-hidden":"true"}},[a._v("#")]),a._v(" Node中的事件循环是什么？")]),a._v(" "),e("p",[a._v("它是一个无限的while循环，调用Epoll（Kqueue）“等待”或“池”，当Node.js发生（回调、事件、fs）时，它会路由到Node.js，并且在Epoll没有等待的情况下退出")])])}),[],!1,null,null,null);t.default=s.exports}}]);