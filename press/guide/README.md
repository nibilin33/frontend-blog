## HTML的盒子模型有哪些构成，盒子模型有哪几种，默认的是哪一种    
content-box

## 盒子模型有没有办法把宽度设置为包含padding的     
border-box

## 浮动元素有没有什么特征     
特征：
浮动元素会脱离正常的文档流，按照其外边距指定的位置相对于它的上一个块级元素（或父元素）显示
浮动元素后面的块级元素的内容会向此浮动元素的外边距靠齐，但是边框和背景却忽略浮动元素而向上一个任意非浮动元素靠齐
浮动元素后面的内联元素会向此浮动元素的外边距靠齐

float造成的影响：       
1、对其父元素的影响
对于其父元素来说，元素浮动之后，它脱离当前正常的文档流，所以它也无法撑开其父元素，造成父元素的塌陷
2、对其兄弟元素（非浮动）的影响     
如果兄弟元素为块级元素，该元素会忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过z-index属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素。
如果如果兄弟元素为内联元素，则元素会环绕浮动元素排列。
3、对其兄弟元素（浮动）的影响           
同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面
反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下
4、对子元素的影响       
当一个元素浮动时，在没有清除浮动的情况下，它无法撑开其父元素，但它可以让自己的浮动子元素撑开它自身，并且在没有定义具体宽度情况下，使自身的宽度从100%变为自适应（浮动元素display:block）。其高度和宽度均为浮动元素高度和非浮动元素高度之间的最大值。

## 清除浮动的所有方法     
1. clear:both
2. overflow:hidden  

## cookie有哪些特征           
cookie可以实现跨页面全局变量        
cookie可以跨越同域名下的多个网页，但不能跨越多个域名使用        
同一个网站中所有页面共享一套cookie      
可以设置有效期限        
存储空间4-10KB左右      
cookie面临的问题：      
CSRF(跨站请求伪造)攻击，这个也好解决，很多框架都屏蔽这个问题        
有的客户端不支持cookie，需要手动设置，比如小程序
浏览器对cookie有限制，不能手动设置cookie，对于混合嵌套的开发有问题，比如小程序跳转H5页面，不能携带cookie        
浏览器对单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie      

## cookie的其他解决方案           
session 是另一种记录服务器和客户端会话状态的机制    
session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中   

### Cookie 和 Session 的区别    
安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。      
存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。     
有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。     
存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。   

### 什么是 JWT
JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。    
是一种认证授权机制。    
JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。    
可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。   

### Token 和 JWT 的区别   
Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。     
JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。     

session面临的问题：     
负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享seesion。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。        
每个客户端只需存储自己的session          id，但是服务端却需要存储所有用户session      id，对服务器也是一个压力        
token的意思是“令牌”，是用户身份的验证方式，最简单的token组成：sign(签名，经过加密后的数据)，相当于上文提到的session id。token可以放在header、url中，在每次网络访问都携带，一般是写请求头header中。相比于cookie，你可以认为只是存储的地方参数不同而已。token相比于cookie就是有cookie的功能，没有cookie的限制。比如其他客户端不会限制header的cookie。token是cookie很好替代品。      

解决方案        
针对上面提到问题，人们想到的办法是用token代替cookie和seesion。一个token怎么替代两个的呢？
服务端把用户信息加密（token）传给客户端，客户端每次访问都返回token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session id占用存储空间，就很好的解决负载均衡多服务器的问题了      

## localstorage存数据的格式是什么 

localStorage存储数据的格式都是以字符串的形式来存储的           
16怎样将一个数组存入localstorage        
17storage有哪些存储方法    
读取属性
getItem 
18html5的一些新的特性        

## 箭头函数      

引入箭头函数有两个方面的作用：更简短的函数并且不绑定this        

箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj.            

## 如果一个页面要做性能优化，从哪方面考察，从哪些地方优化     
https://segmentfault.com/a/1190000010927816

## 请解释原型继承（prototypal inheritance）的工作原理  
每一个对象都包含一个原型属性，用于关联另一个对象，关联后就能使用那个对象的属性和方法，这就是js的原型式继承。
> 所有 JS 对象都有一个prototype属性，指向它的原型对象。当试图访问一个对象的属性时，   

如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，    
直到找到一个名字匹配的属性或到达原型链的末尾。这种行为是在模拟经典的继承，但是与其说是继承，不如说是委托（delegation）。


## 说说你对 AMD 和 CommonJS 的了解   

它们都是实现模块体系的方式，直到 ES2015 出现之前，JavaScript 一直没有模块体系。CommonJS 是同步的，而 AMD（Asynchronous Module Definition）从全称中可以明显看出是异步的。CommonJS 的设计是为服务器端开发考虑的，而 AMD 支持异步加载模块，更适合浏览器。

(前端模块化：CommonJS, AMD, CMD, ES6)

 
## 埋点的实现思路      

> 代码埋点、可视化埋点和无痕埋点   

如果埋点的事件较多，或者说网页内部交互频繁，可以通过本地存储的方式先缓存上报信息，然后定期上报。

## 文件上传断点、续传   

1. 把文件按大小1M分割成N份
2. 每次上传时，告诉后台大文件的md5、当前第几份（从0开始）、总共几份
3. 并行上传，前端同时开启5个请求进行传输增加速度
4. 上传失败或出错后，继续上传下一份，把出错的份放在队尾，如果一直出错则中断请求防止死循环
5. 后台接受文件后通过md5进行比对，上次是否接受过此文件，如果接受则跳过，最后进行文件合并出来     

## VUE/React diff 算法的大概思路    

> react diff 原理    
react中diff算法实现流程:
    DOM结构发生改变-----直接卸载并重新create        
    DOM结构一样-----不会卸载,但是会update变化的内容所有同一层级的子节点.他们都可以通过key来区分-----同时遵循1.2两点   (其实这个key的存在与否只会影响diff算法的复杂度,换言之,你不加key的情况下,diff算法就会以暴力的方式去根据一二的策略更新,但是你加了key,diff算法会引入一些另外的操作)       
把树形结构按照层级分解，只比较同级元素。         
给列表结构的每个单元添加唯一的 key     属性，方便比较。 
React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）  
合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.
选择性子树渲染。  
开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。  

> vue中diff算法实现流程：     
    1.在内存中构建虚拟dom树     
    2.将内存中虚拟dom树渲染成真实dom结构        
    3.数据改变的时候，将之前的虚拟dom树结合新的数据生成新的虚拟dom树
   4.将此次生成好的虚拟dom树和上一次的虚拟dom树进行一次比对(diff算法进行比对)，来更新只需要被替换的DOM，而不是全部重绘。在Diff算法中，只平层的比较前后两棵DOM树的节点，没有进行深度的遍历。
    5.会将对比出来的差异进行重新渲染
    vue diff        
当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。 
        

## 虚拟DOM算法思路   

> 用JS对象模拟DOM树

比较两棵虚拟DOM树的差异
把差异应用到真正的DOM树上
     

## webpack中 loader、plugin 的实现思路   
Loader:能把源文件经过转化后输出新的结果
Webpack通过Plugin机制让其更加灵活，以适应各种应用场景。 在Webpack运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过Webpack提供的API改变输出结果。


    

## 前端构建工具的、vue-cli、create-react-app 的原理和实现思路      
![vue-cli](https://pic2.zhimg.com/80/v2-b487d3a06dbf5ddf8caab18f13616485_hd.jpg)


## 事件委托？原理、好处、应用场景。     

事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器。当触发子元素时，事件会冒泡到父元素，监听器就会触发。        
这种技术的好处是：
内存占用减少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。
无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。    

## vue和react的区别。        

1.react整体的思路就是函数式，所以推崇纯组件，数据不可变，单向数据流.     
而vue是基于可变数据的，支持双向绑定.
2.vue内置了很多功能，而react做的很少，很多都是由社区来完成的，vue追求的是开发的简单，而react更在乎方式是否正确。        

## VUEX的原理

vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件   

## 闭包     

> 闭包是函数和声明该函数的词法环境的组合。

词法作用域中使用的域，是变量在代码中声明的位置所决定的。闭包是即使被外部函数返回，依然可以访问到外部（封闭）函数作用域的函数。    
为什么使用闭包？    
利用闭包实现数据私有化或模拟私有方法。这个方式也称为模块模式（module pattern）。    
部分参数函数（partial applications）柯里化（currying）.

## 匿名函数的典型应用场景是什么

匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。        

(function() {
  // 一些代码。
})(); 
匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。
当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。         
匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。

## 宿主对象（hostbjects）和原生对象（native objects）的区别是什么

1. 原生对象是由 ECMAScript 规范定义的 JavaScript 内置对象，比如String、Math、RegExp、Object、Function等等。       

2. 宿主对象是由运行时环境（浏览器或 Node）提供，比如window、XMLHTTPRequest等等。 

## call和.apply有什么区别？

.call和.apply都用于调用函数，       

第一个参数将用作函数内 this 的值。然而，
.call接受逗号分隔的参数作为后面的参数，而.apply接受一个参数数组作为后面的参数。一个简单的记忆方法是，
从call中的 C 联想到逗号分隔（comma-separated），从apply中的 A 联想到数组（array）。
function add(a, b) {
  return a + b; 
}
console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3

## 功能检测（feature detection）、功能推断（feature inference）和使用 UA 字符串之间有什么区别？

功能检测包括确定浏览器是否支持某段代码，以及是否运行不同的代码（取决于它是否执行），以便浏览器始终能够正常运行代码功能，而不会在某些浏览器中出现崩溃和错误。例如：
if ("geolocation" in navigator) {
  // 可以使用 navigator.geolocation
} else {
  // 处理 navigator.geolocation 功能缺失
}
Modernizr是处理功能检测的优秀工具。
功能推断与功能检测一样，会对功能可用性进行检查，但是在判断通过后，还会使用其他功能，因为它假设其他功能也可用.
UA 字符串这是一个浏览器报告的字符串，它允许网络协议对等方（network protocol peers）识别请求用户代理的应用类型、操作系统、应用供应商和应用版本。它可以通过navigator.userAgent访问。

## 单页应用有那些优缺点

好处：
用户感知响应更快，用户切换页面时，不再看到因页面刷新而导致的白屏。      
对服务器进行的 HTTP      请求减少，因为对于每个页面加载，不必再次下载相同的资源。        
客户端和服务器之间的关注点分离。可以为不同平台（例如手机、聊天机器人、智能手表）建立新的客户端，而无需修改服务器代码。只要 API 没有修改，可以单独修改客户端和服务器上的代码。
坏处：      
由于加载了多个页面所需的框架、应用代码和资源，导致初始页面加载时间较长。          
服务器还需要进行额外的工作，需要将所有请求路由配置到单个入口点，然后由客户端接管路由。         
SPA 依赖于 JavaScript        来呈现内容，但并非所有搜索引擎都在抓取过程中执行 JavaScript，他们可能会在你的页面上看到空的内容。   
这无意中损害了应用的搜索引擎优化（SEO）。然而，当你构建应用时，大多数情况下，搜索引擎优化并不是最重要的因素，因为并非所有内容都需要通过搜索引擎进行索引。        
为了解决这个问题，可以在服务器端渲染你的应用，或者使用诸如 Prerender 的服务来“在浏览器中呈现你的 javascript，保存静态 HTML，并将其返回给爬虫”。   
        
## 请说明 JSONP 的工作原理，它为什么不是真正的 Ajax？  

JSONP（带填充的 JSON）是一种通常用于绕过 Web 浏览器中的跨域限制的方法，因为 Ajax 不允许跨域请求。        

JSONP 通过script标签发送跨域请求，通常使用callback查询参数，例如：https://example.com?callback=printData。        
然后服务器将数据包装在一个名为printData的函数中并将其返回给客户端。
<script>
  function printData(data) {

    console.log( `My name is ${data.name}!` );

  }
</script>
<script src="https://example.com?callback=printData"></script>
printData({ name: "Yang Shun" }); 
客户端必须在其全局范围内具有printData函数，并且在收到来自跨域的响应时，该函数将由客户端执行。
JSONP 可能具有一些安全隐患。由于 JSONP 是纯 JavaScript 实现，它可以完成 JavaScript 所能做的一切，因此需要信任 JSONP 数据的提供者。
现如今，跨来源资源共享（CORS） 是推荐的主流方式，JSONP 已被视为一种比较 hack 的方式。

## "attribute" 和 "property" 之间有什么区别？
“Attribute” 是在 HTML 中定义的，
而 “property” 是在 DOM 上定义的。

## document 中的load事件和DOMContentLoaded事件之间的区别是什么？

当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，而无需等待样式表、图像和子框架的完成加载。             

window的load事件仅在 DOM 和所有相关资源全部完成加载后才会触发。      

## 什么是"use strict"; ？使用它有什么优缺点？

use strict' 是用于对整个脚本或单个函数启用严格模式的语句。严格模式是可选择的一个限制 JavaScript 的变体一种方式 。

优点：      
无法再意外创建全局变量。        
会使引起静默失败（silently fail，即：不报错也没有任何效果）的赋值操抛出异常。      
试图删除不可删除的属性时会抛出异常（之前这种操作不会产生任何效果）。        
要求函数的参数名唯一。      
全局作用域下，this的值为undefined。     
捕获了一些常见的编码错误，并抛出异常。      
缺点：      
无法访问function.caller和function.arguments。
以不同严格模式编写的脚本合并后可能导致问题。    

## 什么是事件循环？调用堆栈和任务队列之间有什么区别？

> 事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。   

如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。    

## let和var的区别。let产生的背景？ 

用var声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。 

let和const是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问。        
为什么会添加这个块级作用域，就得了解ES5没有块级作用域时出现的问题。   
场景一是内层变量可能会覆盖外层变量。    
场景二是在if或者是for循环中声明的变量会泄漏成为全局变量。   

## 请阐述块格式化上下文（Block Formatting Context）及其工作原理。    

块格式上下文（BFC）是 Web 页面的可视化 CSS 渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。
一个 HTML 盒（Box）满足以下任意一条，会创建块格式化上下文：
float的值不是none.
position的值不是static或relative.
display的值是table-cell、table-caption、inline-block、flex、或inline-flex。
overflow的值不是visible。
在 BFC 中，每个盒的左外边缘都与其包含的块的左边缘相接。
两个相邻的块级盒在垂直方向上的边距会发生合并（collapse）。更多内容请参考边距合并（margin collapsing）。

## 有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）

visibility: hidden：元素仍然在页面流中，并占用空间。        
width: 0; height:        0：使元素不占用屏幕上的任何空间，导致不显示它。
position: absolute; left: -99999px： 将它置于屏幕之外。      
text-indent: -9999px：这只适用于block元素中的文本。
Metadata： 例如通过使用 Schema.org，RDF 和 JSON-LD。       
WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。
        
## 使用 CSS 预处理的优缺点分别是什么

优点：      

提高 CSS 可维护性。        
易于编写嵌套选择器。          
引入变量，增添主题功能。可以在不同的项目中共享主题文件。           
通过混合（Mixins）生成重复的 CSS。            
将代码分割成多个文件。不进行预处理的         CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。         
缺点：      
需要预处理工具。           
重新编译的时间可能会很慢。          

## 什么情况下，用translate()而不用绝对定位？什么时候，情况相反      

translate()是transform的一个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），         
只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。transform使浏览器为元素创建一个 GPU 图层，         
但改变绝对定位会使用到 CPU。         因此translate()更高效，可以缩短平滑动画的绘制时间。          
当使用translate()时，元素仍然占据其原始空间（有点像position：relative），这与改变绝对定位不同。   


## 请简述JavaScript中的this

粗略地讲，函数的调用方式决定了this的值。this取值符合以下规则：      

在调用函数时使用new关键字，函数内的this是一个全新的对象。        
如果apply、call或bind方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。   
当函数作为对象里的方法被调用时，函数内的this是调用该函数的对象。比如当obj.method()被调用时，函数内的 this 将绑定到obj对象。        
如果调用函数不符合上述规则，那么this的值指向全局对象（global object）。浏览器环境下this的值指向window对象，但是在严格模式下('use strict')，this的值为undefined。    
如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定this的值。          
如果该函数是 ES2015      中的箭头函数，将忽略上面的所有规则，this被设置为它被创建时的上下文。            

## 在浏览器中，一个页面从输入URL到加载完成，都有哪些步骤    
1. 域名解析
2. 建立TCP连接，浏览器与服务器经过3次握手后建立连接   
3. 浏览器发起HTTP气球，获取资源/*-
4. 服务器响应HTTP气球
5. 浏览器渲染   

## HTTP1.1 有哪些不足   
1. 出现队首阻塞问题   
2. 响应不分轻重缓急，只会先来后到   
3. 并行需要建立多个TCP
4. 只能被动等待客户端发起请求
5. HTTP是无状态的，每次请求和响应都会携带大量冗余信息 


## 用new 运算符创建对象时，具体的创建过程有哪几步
1. 一个新对象被创建，它继承自构造函数的原型
2. 将指定的参数传递给构造函数
3. 将执行上下文（this）绑定到新创建的对象中
4. 如果构造函数有返回值，那么返回值将取代第一步中新创建的对象   

## isPrototypeOf方法与instanceof 运算符有哪些区别
isPrototypeOf 用于检测调用此方法对象是否存在于指定对象的原型链中，`
而instanceof用于检测构造函数的原型是否存在于指定对象的原型链        

## 请介绍一下节流函数和防抖函数，简单实现节流函数和防抖函数
他们都是可以防止一个函数被无意义的高频率调用
区别在于:
函数节流：是确保函数特定的时间内至多执行一次。
函数防抖：是函数在特定的时间内不被再调用后执行。

## 请介绍一下回流（Reflow）与重绘（Repaint） 
回流（Reflow）：render       树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。        

重绘：render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响 render 树重新布局的，比如修改字体颜色。        
注意：回流一定会触发重绘，而重绘不一定会回流。        

## 请描述一下什么是执行栈  
可以把执行栈认为是一个存储函数调用的栈结构，它遵从先进后出的原则。  

## Vue通信
1.props和$emit
2.EventBus(基本不用)
3.vuex

[react](http://react-china.org/t/topic/33558)   
[react-github](https://github.com/sudheerj/reactjs-interview-questions) 

## 斐波那契数列？怎么优化？

## node主要用来解决什么问题，node做BFF的优点是什么    
## 对项目监控这块有什么了解吗   
## 对微服务有了解吗   
## restful接口架构的优缺点,restful接口架构会导致什么安全问题，具体怎么解决    
## Webpack性能优化你知道哪些  
## 如何设计一个组件？   
## Vue发展问题在哪里？    
## 如何实现一个前端错误收集系统？    
## code split 怎么做？   
## 什么是treeshaking？注意些什么？   
## 一像素问题怎么解决？    
## JSBridge原理是什么？如何设计一个JSBridge？
## 离线包怎么设计？    
## Hybrid  H5开发需要注意些什么？    
## Webview的缓存机制是什么？   
## 有哪些监控网页卡顿的方法   
网页内容在不断变化之中，网页的 FPS 是指浏览器在渲染这些变化时的帧率。   
帧率越高，用户感觉网页越流畅，反之则会感觉卡顿。    
每秒钟计算一次网页的 FPS 值，获得一列数据，然后分析。   
通俗地解释就是，通过 requestAnimationFrame API 来定时执行一些 JS 代码，   
如果浏览器卡顿，无法很好地保证渲染的频率，1s 中 frame 无法达到 60 帧，即可间接地反映浏览器的渲染帧率。      
## 如果需要手动写动画，你认为最小时间间隔是多久，为什么？   
显示器默认频率是60HZ，即1秒刷新60次，故最小时间间隔是 1000/60 = 16.7毫秒   
## 什么是Cookie 隔离    
若静态文件位于主域名下，请求静态文件时会携带cookie到服务器，浪费流量，故需隔离。    
由于cookie有域的限制，不能跨域提交请求，故将静态文件置于非主要域名下，请求静态文件时便不会携带cookie数据。如此可降低请求头大小和请求时间，以便达到降低整体请求耗时的目的。       
## Chrome 打开一个页面需要启动多少进程？分别有哪些进程？
打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；   
最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。   

浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。    

渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。    

GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。      

网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。      

插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。            

## Node 面试题
严格路由和不严格路由有什么区别  
strict 严格路由，例如 /foo 和 /foo/ ，默认false关闭。
-------------------------------------------
如何设置路由不敏感或严格路由  
caseSensitive:true
strict:true
---------------------------------------
什么是lazy router以及为什么要lazy router  
生成默认路由对象。
无法在默认配置中添加基本路由器，因为可能在运行之后设置的应用程序设置。 
-----------------------------------------------------
trust proxy什么用 
req.ip获取到的ip将是实际客户端的ip
否则，获取到的是代理服务器的ip.
-----------------------------------------------
Etag weak 和strong有什么区别 
strong 要完完全全一样 
weak 页面内容一样，只是时间戳不一样可以回一个一样的etag。
----------------------------------------   
app.all和app.use的区别及性能差异    
all 执行完整匹配,use 只匹配前缀 ，
all是路由中指代所有的请求方式，use是中间件。  
-------------------------------------
如何捕捉next(err)传递的错误   
express中内置了一个错误处理程序。如果请求内的同步代码抛出异常或调用next(err)，那么 Express 会将当前请求视为处于错误状态，并跳过所有剩余的非错误处理路由和中间件函数，最后被内置的错误处理程序处理。
---------------------------
路由function内部的错误是在哪个环节捕捉的
---------------------------------------
Node.js为什么处理异步IO快?      
Node中的错误怎么捕获？    
Node中遇到错误，进程退出了怎么办？    
Promise的错误如果统一捕获？   
Promise中的ajax 可以try catch 到么？    
项目中的中间层Node 在处理什么问题？
Node 的Cluster模式是什么？    
Node 中的进程和线程啥区别？
Node 中如何创建一个进程？
Node的多个进程如何通信？
Koa2 中的 context如何实现？
如何监控Node？
Node中的日志如何保整串行？
Node 挂掉怎么办？怎么发现其中的问题？
Node中的事件循环是什么？

