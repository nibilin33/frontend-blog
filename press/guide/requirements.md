## 介绍
   这份文档仅供统一项目编码风格  
#### 基本概念
**实体（Entities）**，实体用于封装企业范围的业务规则。实体可以是拥有方法的对象，也可以是数据结构和函数的集合。如果没有企业，只是单个应用，那么实体就是应用里的业务对象。这些对象封装了最通用和高层的业务规则，极少会受到外部变化的影响。任何操作层面的改动都不会影响到这一层。  
**用例（Use Cases）**，用例是特定于应用的业务逻辑，一般用来完成用户的某个操作。用例协调数据流向或者流出实体层，并且在此过程中通过执行实体的业务规则来达成用例的目标。用例层的改动不会影响到内部的实体层，同时也不会受外层的改动影响，比如数据库、UI 和框架的变动。只有而且应当应用的操作发生变化的时候，用例层的代码才随之修改。  
**接口适配器（Interface Adapters）** ，接口适配器层的主要作用是转换数据，数据从最适合内部用例层和实体层的结构转换成适合外层（比如数据持久化框架）的结构。反之，来自于外部服务的数据也会在这层转换为内层需要的结构。  
#### 目录即分层的具体实践  

#### 文件名文件结构 
   1.文件名全部为小写或包含-  
   2.单文件组件的顶级元素的顺序template,script,style  
   3.script的

#### 命名规则
css 采用BEM命名规则  
例：  
.ListCard 块，高层次组件  
.ListCard__title 元素  
.ListCard--feature 修饰符，表示不同状态  
#### 注释  
尽量利用函数名称，参数或者返回值自身就足够传达信息。    
短函数不需要太多描述，为只做一件事的短函数选个好名字，比写函数头注释要好。  
**好注释**  
1.对意图解释的注释    
2.用于警告其他程序员会出现某种后果的注释  
3.TODO注释  
**写注释的常见动机之一是糟糕代码的存在，与其花时间编写解释你搞出的**  
**糟糕的代码的注释，不如花时间清洁代码。如果编程语言足够有表达里，就不那么需要注释**
#### 函数
函数的第一个规则是要短小，第二条规则是只做一件事。
#### 项目README
- 运行命令
- 线上的示例或者最后的运行环境
- 相关的文档链接
- 相关人员的联系方式或群
- 代码组织结构图

## Typescript 运用 
1.interface ,type 
使用接口来确保类拥有的指定结构，或者约束对象。  
接口好比一个协议，当我们签署它的时候，必须遵守他的规则。  
````
interface ChinaMobile {
    name: string;
    website: string;
}
interface ChinaMobileList {
    // 动态属性
    [phone: string]: ChinaMobile
}
````
2.enum  
3.class,extends   
4.namespace  
命名空间，又称内部模块，用于组织一些具有某些内在联系的特性和对象，使代码结构更清晰。 
例子：
````
namespace app {
  export namespace models {
     export calss UserModel {
     }
  }
}
let user = new app.models.UserModel();
````
 
5.decorators (装饰者模式+切面编程,reflect-metadata)    
面向切面编程主要用于抽离与核心业务逻辑无关的功能，如日志统计、埋点、异常处理等等，  
可以提高业务模块功能的纯净度与被分离模块的复用性。    
装饰器用来为元素添加一些额外的逻辑或者元数据。
装饰器：类，属性，方法，参数  
类装饰器：接受一个类构造函数作为参数的函数  
方法装饰器：接受属性的对象，属性名和一个可选的参数  
属性装饰器： 接受属性的对象和属性的属性名  
参数装饰器： 接受被装饰参数的方法的对象，方法的名字和参数在参数列表中的索引。  
reflect-metadata：反射元数据API  
元数据是指程序本身的信息数据，元数据存储在程序集中;
反射就是在运行时动态获取一个对象的一切信息：方法/属性等等。
````
import 'reflect-metadata'

````
  
6.泛型T ，允许使用的时候定义类型(通用函数的考虑)  
例子：
````
geEntities<T>(url:string):void{
  axois.get(url)
    .then() {
      //todo
    }
}
geEntities<User>("/api/users"):void{

}
````