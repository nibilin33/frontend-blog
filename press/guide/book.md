## Linux操作系统    
OS基本分两部分：shell和kernel（内核）       
内核分两种：宏内核和微内核              
宏内核包含了CPU调度，内存管理，文件系统，中断处理（设备驱动）、应用管理（进程调度），他们跑在同一个CPU上               
微内核只有应用管理，当需要调用其他功能时，微内核去找对应的程序。设置可以通过网络调用。
CPU指令分级有0，1,2，3。               
但Linux中只用0和3，内核是0级，用户态是3级。当用户需要用到0级指令时需要向OS申请，切到内核态执行，然后在切回用户态。            
Linux一切皆文件，Linux最小单位是进程。称为task，用进程描述符PCB描述进程，PCB是个结构体。
父进程维护子进程的PCB，当子进程结束后，主进程没有释放对应PCB，子进程就变成僵尸进程了。
当子进程还没有结束时，父进程退出了，子进程就成了孤儿进程。            
孤儿进程的PCB也转由一个专门处理孤儿进程的进程处理，对于孤儿进程来说他的父进程换了，一般是init（PID1）。图形界面下是转给图形界面进程。                       
也可以理解为转给了父进程的父进程。ps -ef下可以看到图形化界面的父进程是1，在后台启动的程序的父进程也是1。在图形化界面下启动进程父进程是图形化界面的进程                  
Linux2.5内核的进程调度策略是绝对时间片的分时调度策略。时间片大小，一个线程能获得的运行时间是时间片大小*优先级                        
Linux2.6内核的进程调度策略是CFS，这是一种优化调度和时间补偿的策略。这个模式下每个进程能够获得1/n的处理器时间，n是可运行进程数                    
这种模式下可以设置目标延迟，比如目标延迟是20ms，现在有两个可运行进程是2，优先级是5和15，那么他们就会分别得到5ms和15ms的虚拟运行时间           
这些信息被存在调度器实体结构中，OS在用红黑树存储他们，每次执行会选取虚拟允许时间最小的进程。因此红黑树会存下最左节点。              
当轮到进程A执行时，进程A不需要全部的时间片就能完成了，此时OS会让下一个进程先执行。
过了一段时间进程A有响应了，OS发现A进程之前让出了资源，现在就会优先给进程A执行，这是一种补偿。             
这种模式下时间片不是固定的，而是按照百分比分配的。进程的优先级越高就能够分配到更多的时间。
实时进程的优先级是0-99，普通进程的优先级是-20-19。实时进程是一定要优先于普通进程的。实时进程用自己的调度策略。             
实时进程的优先级数字越高，优先级越高。而普通进程的是nice值，数值越低优先级越高。        
CFS只是普通进程调度器，实时进程不适用CFS             
Linux使用的软亲和的，会尽量保证进程在同一CPU上执行                     
进程可以主动放弃处理器时间，此时进程会被移除活动队列，加入到过期队列，保证他们一段时间不被执行                      
但实时进程只会被放到优先队列的尾部      
在Linux创建进程的时候可以指定进程的调度策略，有SCHED_OTHER（默认）、SCHED_RR和      SCHED_FIFO，后两张是实时进程的。              
`SCHED_OTHER` 分时调度策略，默认策略        
`SCHED_FIFO`  实时调度策略，先到先服务      
`SCHED_RR`    实时调度策略，时间片轮转      
### 中断机制
Linux需要对硬件的信号做出相应。硬件会给中断控制器ICU发送信号。这种中断被成硬中断
而软件也可以进行中断，这种中断被称为软中断，软件需要调用系统API函数的时候就需要软中断
软中断调用时将返回地址和CPU状态寄存器内容压栈，修改特权级，根据中断号查找中断向量表，找到ISR中断服务例程地址，跳转执行。        
软中断原来是需要内核执行 int(0x80)，现在新的CPU中有提供sysenter原语，直接在CPU硬件成名支持了软中断      
`软中断流程`：java读网络 -> JVM read() -> c read() -> 内核空间 -> system_call() -> sys_read()           
`硬中断流程`：硬件产生中断->中断控制器->处理器->处理器中断内核->判断是否存在对应中断处理程序有就执行->返回内核运行中断的代码                   
内核处理中断的时候要先差中断向量表找到对应中断信号的含义        
中断的上半部和下半部：      
中断上半部是中断处理程序，接到一个中断后要立即执行，比如响应。而下半部是可以不用立即执行的
中断下半部是一些推工作，目前实现机制有三种：tasklet、工作队列和软中断（不是上面提到的软中断，上面那是是软件中断的简称）         
下半部在在过去只有一种方式可以实现————BH机制，后来引入了上面三种以及任务队列（已弃用）              
`中断处理程序`:中断处理程序是可以设置标志的，这些标志有有能在处理中断时禁用其他中断的标志，也有声明该中断对内核熵池有贡献的               
内核熵池负责各种随机事件，可用于参数真正的随机数            
`下半部的软中断`： 软中断是在编译期间静态分配的，它不像tasklet可以动态注册或者注销。它需要加入到一个数组中，这个数组最大是32。      
因此最多只能有32个软中断，目前只有9个软中断。其中一个是tasklet
内核在处理软中断的时候会被整个数组传递给软中断处理程序。每个软中断可以在不同的CPU上同时执行。           
软中断有三种触发方式：一个硬件中断代码处返回时；在软中断内核线程中；在显示检查或者执行待处理软中断的代码中，比如网络子系统                  
`tasklet`：tasklet中有一个引用计数器。不为0时该tasklet被禁用。为0表示激活，并被挂机，根据优先级被分配到普通队列和高优先级队列。tasklet虽然是软中断实现的，但不同的tasklet也可以在不同的CPU上并行        
`工作队列`:工作队列使用工作者线程完成，工作者线程都是普通的内核线程;             
因此工作队列有休眠的能力，当中断推后工作中需要休眠，就可以使用工作队列     

`三种下半部机制的对比`:     
1. 软中断，是一种中断，必须静态创建，不能保障中断顺序执行（软中断可以在不同CPU上执行）      
2. tasklet，软中断实现，因此也是一种中断，但不能保障同类型的顺序执行（同类型不能同时执行）      
3. 工作队列，内核进程实现，因此执行休眠，具有进程上下文。       
`阻塞`:程序会有用户态和内核态，阻塞就是程序进入内核态，用户态会阻塞     
`休眠与唤醒`:
调度器可能会选中一个休眠（处于不可运行状态，即处于可中断和不可中断状态）的进程，为了避免这种的时间浪费，也为了方便唤醒      
OS中设计了等待队列，进程要休眠时将自己加到等待队列里，当需要检查唤醒时也只要检查等待队列。这也是前面CFS优化调度的方法。     
`抢占与上下文切换`:
进程的休眠与唤醒都需要schedule()。内核需要知道什么时候要执行，用户可以显示的调用schedule也可以通过设置标志。        
在2.2之前这个标志是全局的，2.2-2.4的版本中把它移动到了task_truck，而2.6进一步移动到了thread_info中。        
schedule会导致抢占。因此在系统调用或者中断处理返回用户空间的时候都会发生用户抢占。      
2.6的版本中内核也是可以被抢占的。当中断处理程序正在进行并且没有返回用户空间前，内核可以被抢占       
如果内核任务中有显示的调用schedule或者任务阻塞（就是休眠，上文提到休眠会调用schedule）都会发生内核抢占      
`进程上下文`:
进程上下文事实上是进程执行全过程的静态描述，已经被执行过的成为上文，正在执行的成为正文，待执行的称为下文        
`中断栈`:
原本中断是使用内核栈，内核栈大小是2页。但在2.6早期，内核栈可以是一页，因此就需要中断栈
中断栈每个CPU一个，大小是一页。也是说在32位系统下是4KB，在64位下是8KB;  
中断是可以被禁止的。可以禁止某个中断处理程序不会抢占当前代码。禁止中断还可以禁止内核抢占。
但不过是禁止中断还是禁止内核抢占，都没有提供任何保护机制来防止来自其他处理的并发访问。      
因此内核代码一般要通过获取锁来防止并发。            
`临界区`:
临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段
### 锁
内核中可能导致并发的情况有：中断,软中断和tasklist,内核抢占,睡眠及与用户控件的同步,
对称多处理（SMP）。     

Linux中大多数的锁都平平无奇，就是常见的锁。但Linux2.6引入了一个顺序锁。     
顺序锁中有个计数器，计数器从0开始，当一个写操作开始的时候，计数器会+1，写完成后再+1。
而读操作不会改变计数器，但读操作可以通过计数器的值判断自己要不要读。
因为当计数器是奇数的时候，表面当前有写操作正在进行，读操作可以选择读，也可以选择自旋，等待计数器变成偶数。
Linux的atomic操作：将int分为高24位和低8位。低8位用于做版本号。高24位才是真正的值。
Linux的自旋锁：Linux的自旋锁是不可重入的。自旋锁是不允许睡眠的。因此使用信号量就不能使用自旋锁。        
`信号量`:java中内核级的锁就是信号量实现的，利用KV操作（down up操作）对信号量进行修改，以此表示不同的锁状态。一旦一个进程尝试获取信号量失败后，进程就会进入睡眠，加入信号量的等待队列。信号量分二值信号量和计数信号量。共享锁就是个计数信号量。互斥信号量就是二值信号量
互斥体。就是个不可重入互斥锁。      
相对于可以通用的信号量，互斥体有严格的使用规范：
1. 同时只能被一个进程持有，计数只能是1      
2. 上下文中不可重复锁定同一个互斥体     
3. 不可递归使用     
4. 不能在中断或者下半部中使用       
`读写屏障`:与java相同可以防止指令重排序。有读屏障（rmb）写屏障（wmb）读写屏障（mb）。
Intel x86处理器不会对写进行重排序。     

### 内存管理
页是内核管理内存的基本单元。32位系统中一页是4K，64位系统中一页是8K。
在结构体page中有flag用来标记页是否为脏。_count存放页的引用计数。virtual是页的虚拟地址
区。这是因为物理原因一些页在特定的为例地址上，不能用于一些特定的任务，就会被划分为不同的区。
一些硬件只能通过特定的内存地址来执行DMA（直接存储器访问）
还要一些体系结构的内存物理寻址地址比虚拟地址寻址范围大，这些内存不能永久的映射到内核空间上。
因此Linux将内存分为四种区：     
1. DMA区，这些页能直接进行DMA操作（32位中物理内存小于16MB）     
2. DMA32区，只能被32位设备访问的DMA区       
3. 通常区（normal），就是正常映射的页       
4. 高端内存区（highEM），不能被永久映射到内核空间上的页（32位中物理地址大于896MB）      

Linux内核提供一个特殊的函数————kmalloc()能互道一个以字节位单位的内存块。对应的kfree函数用于释放内存快       
这两个函数都在slab层上操作。slab层是一个高速缓存的管理结构。        
`内存描述符`:
内存描述符是用来表示进程的地址空间。这是一个mm_struct结构体。       
进程是可以共用同一个内存描述符的，共用同一个内存描述符的进程被称为线程      
内核进程是没有内存描述符，也就是内核线程没有用户空间内存        
当一个进程被装载到内存，进程描述符中active_mm会被更新指向新的地址空间       
而内核线程没有地址空间，所以他的mm是null，内核线程会使用上一个进程的地址空间，然后更新自己的active_mm       

`虚拟内存区域`: 
VMA，虚拟内存区域，与VFS相识，用来描述内存区域。包含了区间的首位地址，控制权限，VMA标志等信息       
VMA与VFS一样需要缓存，要查找一个VMA可以先去查缓存，用红黑树的方式查找       
VMA标志:标示了区间的可操作权限，可扩展方向，映射目标，是否连续，能否拷贝等信息      

`mmap和do_mmap创建地址区间`:
do_mmap可以创建一个新的先行地址区间。如果创建的VMA地址与一个已存在的VMA相邻，他们就会合并       
do_mmap是一个内核函数，用户空间可以通过mmap系统调用     

`页表`:
虚拟内存需要映射到物理内存上。Linux使用三级页表完成虚拟内存到物理内存的地址转换。
利用多级页表能够结缘地址转换需要占用的存放空间。用三级页面在64位的机器占用的空间也很有限。      
但如果用静态数组实现的话，在32位机器上数组也将占用巨大的空间        
Linux对所有体系结构都使用三级页表进行管理。因为三级页表可以利用最大公约数的思想     
多级页表可以使用TLB做硬件加速，这是个页表缓存       

### 文件管理
使用虚拟文件系统（VFS，也有称虚拟文件交互的）。这种方法可以屏蔽底层，支持多种存储设备挂载，而进程只需要在VFS上操作。            
Unix中有4种文件相关的抽象概念：文件、目录项、索引节点和安装点       
`索引节点`是Unix中为了区分文件内容和文件本身而引入的概念        
`文件`内容被称为文件，而文件本身即用来描述文件信息会被存在索引节点内        
VFS中有四种主要对象：       
1. 超级块对象，代表一个具体的已安装的文件系统。文件系统安装时，文件系统会读取磁盘填充超级块信息     
2. 索引节点对象，代表一个具体的文件。只有当文件被访问时才会在内存中被创建。     
3. 目录项对象，代表一个目录项，是路径的一个组成部分。VFS中目录也是被视为文件。但目录毕竟有自己的一些操作，因此引入了这个对象        
4. 文件对象，代表一个由进程打开的文件，也就是fd。有open系统调用创建，有close系统调用撤销。      
目录项对象有三种状态，状态值大于0时表示存在一个或者多个使用者，等于0表示未被使用。小于0表示没有对应的有效索引节点。     
小于0的情况一般是索引节点被删除了，或者路径不在正确。但目录项对象被保存下来。       
这是一种缓存的思路，如果一个守护进程不断的请求一个不存在的路径，就可以直接使用同一个对象，而不是一直去查找创建。这种也可以放到slab层缓存        
为了避免一直查询创建。VGS中有三种缓存目录项的结构：被使用的目录项链表，最近被使用的双向链表、散列表（散列值有d_hash函数计算）       

文件对象只是表示进程打开了一个对象。它反过来指向目录项对象，目录对象在反过来指向索引节点对象。      
同一个实际文件可以对应多个文件对象，当只会对应一个目录项对象。      
因此文件对象实际上没有对象的磁盘数据，所以结构体上有没有代表对象是否为脏，是否需要写会磁盘的标准        

Linux支持多种不同的文件系统。每一种系统都会对应一个且只有一个file_system_type结构体。这里描述了文件系统的信息。     
文件系统被实际安装时，将会有一个vfsmount结构体在安装点被创建。这个结构体用来代表文件系统的实例，也就是代表一个安装点。      

将VFS层和进程联系在一起的还有三个数据结构：file_struct、fs_struct和namespace。
file_struct有进程的files指向，这结构体中包含了与该进程相关的文件信息（如打开的文件和文件描述符）        
`file_struct`中有个fd_array数组指针指向进程所打开的文件对象，在64位OS中这个数组大小默认是64。一旦超出内核就要分配一个新的数组       
`fs_struct`由进程的fs指向。包含了文件系统和进程的相关信息。这个结构体中爆了当前进程的当前工作目录和根目录。 
`namespace`由进程的mmt_namespace指向。2.4之后的版本中单进程命名空间引入内核，使得一个进程在系统中都能看到唯一的安装文件系统     
这意味着唯一个根目录，唯一的文件系统        

软连接和硬链接的本质：          
`硬链接`：本质上是创建了一个目录项对象，指向了同一个索引节点对象。stat看iNode值两个是一样的，说明是同一个索引节点。     
`软连接`：本质上是创建了一个实际文件，这样就会有对象的索引节点对象。        

### 块IO层
DMA，这是CPU上的一个硬件。用来协助完成IO的。当需要IO的时候，CPU就把总线控制权交给DMA，然后CPU就可以去做其他事情了       
固定大小的数据库片的硬件设备被称为块设备。固定大小的数据片被称为块      
硬盘上最小的寻址单位是扇区，一般是512B。块是内核对对其的抽象描述        
一个块可以包含多个扇区，但大小不能大于一个页        
一个页可以包含多个块            

我们在应用层中的写操作，实际上是先落在缓冲区的。内核会在适当的实际在写到磁盘上      
缓冲区，每个缓冲区对应一个块，可以把缓冲区看为磁盘块在内存上的表示      
旧的设计中缓冲区有缓冲区头，这里描述了缓冲区的信息      

`bio结构体`:
用来表示正在现场执行的IO操作。bio结构体的存在可以让我们使用不连续的IO缓存       
bio结构体内有个BIO向量数组      
`bio向量结构体`:bio向量就是一个缓存结构。里面包含当前缓冲区驻留的物理页，缓冲区大小和对应物理页的偏移量         
bio结构体是取代缓冲区头的一个方案。相比缓冲区头的做法，他有以下优点：       
1. bio结构体很容易处理高端内存，因为他处理的是物理页而不是直接指针      
2. bio结构体既可以代表普通页IO，同时也可以代表直接IO        
3. bio结构体便于执行分散-集中块IO操作。操作中的数据可以取自多个物理页面     
4. bio结构体相比缓冲区头属于轻量级结构体。因为他只需要包含块IO的操作所需的信息就行了，不需要好汉与缓冲区本身相关的不必要信息        

`请求队列`:
块设备将它们挂起的IO请求保持到请求队列中，这个队列是的双向链表。        
只要该队列不为空，队列对应的块设备驱动程序就会从队列头获取请求将其送到对应块设备上      

`IO调度程序`:
IO调度程序决定了请求队列的排列顺序以及什么时候派送到块设备      
IO调度程序会通过合并和排序的方法，减少寻址减低随机IO        
这样可以增大全局吞吐量，但难免对一些IO不公      

`Linus电梯`:
Linux早期的IO调度程序。当请求加入的队列的时候有四种可能：       
1. 已存在一个相邻扇区的操作请求，新请求和旧请求合并     
2. 如果队列中存在一个驻留时间过长的请求，新请求加入到队尾，防止旧请求饥饿       
3. 如果队列中以扇区方向为序存在合适的加入位置，那么新请求插入这个位置       
4. 以上都不满足加入队尾     

`最终期限IO调度程序`:
Linus电梯存在饥饿问题，因为先判断合并在判断饥饿。       
而最终期限IO调度程序使用FIFO队列，分离读写。读写各自使用各自队列        
设置读超时时间是500ms，而写超时是5s         
在设置一个排序队列，一般情况下调度程序是取下排序队列的第一个请求推送到派发队列      
当两个FIFO队列中有请求超时的时候，会优先处理FIFO队列中的超时请求        

`预测IO调度程序`:
这是最终期限IO调度程序的优化版。           
最终期限IO调度程序在提交超时请求后立即返回继续处理下一个请求                    
但这个算法是在提交超时请求后故意的设置几ms的空闲，这个时间是可设置的，默认6ms       
在这个空闲期间其他应用程序提交过来的请求如果与刚刚提交的那个请求相邻就能立即得到处理        
这个空闲中如果没有请求或者很少的请求能够一起提交的话，显然就白浪费了        
因此预测IO调度需要通过一些启发和统计工作来做预测判断要不要停下来        

`完全公平的排队IO调度程序(CFQ)`:
当给每个进程都开辟了队列，以时间片轮转调度，每次取出每个队列相同的请求（默认4个）
这种算法比较适合视频音频等流媒体        

`空操作的IO调度程序`:
佛系算法，只做尽可能的合并（尝试能不能与相邻的合并），维持一个几乎是FIFO的顺序队列
这种算法适合那些没什么寻道负担的设备，比如闪存卡        

### 页高速缓存
页高速缓存是内存中的物理页组成的，其内容对应磁盘上的物理块，大小可以动态调整以用来控制内存压力      
Linux使用回写策略。将所有的写操作都写到缓存上，将被写入的页面标记为脏，然后让回写进程将脏页同步到磁盘上     

`缓存回收`:
缓存可能被写满，需要淘汰，Linux使用简单的替换       
对于替换谁这个问题，Linux使用变种lru算法，使用双链策略      
传统LRU是单链表，有只访问一次的就成为热数据的问题       
Linux使用或活跃和非活跃两个链表。两个链表都由伪LRU维护      
活跃链表不能被换出，当活跃链表的长度大于非活跃链表是，活跃链表表头将移到非活跃链表      

Linux中使用address_space结构管理新对象的缓存项和IO操作      
一个被缓存起来的文件只能和一个address_space对应，但他可以有多个VMA      

`基树`:任何一个IO操作，内核都要检查对应的页是否已经在页高速缓存中了
为了方便检查就有基树，这个是搜索二叉树          

IO操作的是磁盘，IO操作有自己的缓冲区，而页高速缓存存的也是磁盘      
这样就浪费了内存，在2.4的内核中将缓冲区和页高速缓存映射了起来。     
现在磁盘的缓存只有页高速缓存了      

`回写线程（flush线程）`:
只有三种情况会触发回写          
1. 空闲内存低于设定值。内核必须释放脏页，因为脏页是不能回收的。     
2. 脏页在内存中驻留到一定的时间     
3. 用户进程显示调用了sync和fsync系统调用，要求内核回写      


### 基本组成    
1. 用户进程：用户界面，服务器，命令行   
2. Linux 内核： 系统调用，进程管理，内存管理，设备驱动程序  
3. 硬件：CPU，主内存，磁盘，网络端口    
### 目录结构    
/bin 可执行文件    
/dev 设备文件    
/etc 系统配置文件    
/home 用户个人目录    
/lib 供可执行程序使用的各种代码库    
/lib 一般放共享库 /usr/lib 存放静态库和动态库    
/proc 可浏览的目录与文件接口来存放系统相关的信息        
/sys 类似 /proc，里面是设备和系统信息    
/sbin 可执行文件系统，用来管理系统    
/usr 很多目录与/root相同,为了让文件系统占用尽可能少的空间  
/usr/include C编译器需要使用的头文件    
/usr/local 管理员安装软件的地方    
/tmp 临时文件，系统启动的时候会清掉
/var 程序存放运行时信息的地方，如系统日志，用户信息，缓存。
/var/tmp 系统启动的时候不会清掉        
/boot 存放内核家长文件    
/media 加载可移除设备    
/opt 第三方软件   
### Shell 脚本  
vscode 安装 shell-format    
1. 以下行开头 
```
#!/bin/sh   
```
2. #为注释      
3. 给shell 脚本设置执行和读位(让shell能读取该文件)：chomd +rx script    
4. 变量 
```
length = 100    
$length 
整数命名：$1,$2... 命令行参数   
$0 脚本名   
$$ 进程号   
$? 退出码   
shell会对双引号内的变量进行转化 
"$100"
$@ 命令行所有参数       

```
5. 关键字       
if/then/else/elif/case/for/while    
条件判断止于fi,easc 
```
if ["$1" = "hi"];then   
elif["$2" = "bye"];then 
else
    echo "end"
fi  
```
```
for filename in *;do   
    code
done    
while true;do
done    
```
``` 
case $1 in
    bye)
        echo "Fine"
        ;;
easc
```
### 常用命令    
less:翻页查看，q退出    
fork命令        
    fork出来的是一个子进程，这个父进程是可以通过copy on write给子进程提供一份内存快照的。
copy on write       
    子进程获得一份内存快照，这份快照是一份指针集合，指向父进程给它时那些内存。父进程修改了某个值时，只是父进程的指针指向了一个新的内存地址。
    子进程和父进程维护各自的指针集合，互不影响。
管道、$$和$BASHPID的优先级
    $$和$BASHPID都是当前进程ID。优先级上不一样。优先级从高到低是$$>管道>$BASHPID

egrep命令       
    grep的增强版，可以使用正则
## Webkit技术内幕   

主流的演染引擎包括 Trident 、 Gecko 和 webkit，它们分别是 IE 、火狐和 Chrome 的内核。   
一个渲染引擎包括：HTML解释器， CSS解释器， 布局，Javascript引擎。   
渲染过程：输入到 HTML 解释器， HTML 解释器在解释它后构建成一棵 DOM 树，     
如果遇到 Javascript 代码则交给 Javascript 引擎去处理；  
如果网贞中包含 CSS ，则交给 CSS 解释器去解释。  
当 OOM 建立的时候，渲染引擎接收来自 CSS 解释器的样式信息，构建一个新的内部绘图模型。    
该模型由布局模块计算模型内部各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。      

### HTML(hypertext markup language) 

HTML5 包括10大类别：  

| 类别                  |                                           内容                                          |
|-----------------------|:---------------------------------------------------------------------------------------:|
| 离线（offline）         |                 Application cache , Local storage , Indexed DB ，在线／离线                |
| 存储（storage）         |                    Application cache , Local storage , Indexcd DB 等                    |
| 连接（connectivity）    |                              Web Sockets , Server-sent 事件                             |
| 文件访问（file access）  |                   File API , File System , Filewriter , ProgressEvents                  |
| 语义（semantics）       | 各种新的元素，包括 Media , structural ，国际化，Link relation ，属性， form 类型， microdata 等方面 |
| 音频和视频（audio/video） |                     HTMLS Video , Web Audio , WebRTC, Video track 等                    |
| 3D和图形（3D/graphics）  |                          Canvas ZD , 3D CSS 变换， WebGL , SVG 等                         |
| 展示（presentation）    |                    css3 2D/ 3D 变换, 转换（ transition ) , webFonts 等                    |
| 性能（performance）     |                               web worker , HTTP caching 等                              |
| 其他（Nuts and bolts）  |                          触控和鼠标， Shadow DoM , css masking 等                          |

### Webkit渲染过程

1. 当用户输入网页 URL 的时候, WebKit 调用其资源加载器加载该 URL 对应的网页。 
2. 加载器依赖网络模块建立连接，发送请求并接收答复。 
3. WebKit 接收到各种网页或者资源的数据，其中某些资源可能是同步或异步获取的。    
4. 网页被交给 HTML 解释器转变成一系列的词语（ Token ）。    
5. 解释器根据词语构建节点（ Node ) ，形成 DOM 树。  
6. 如果节点是 Javascript 代码的话，调用 Javascript 引擎解释并执行。     
7. Javascript 代码可能会修改 DOM 树的结构。     
8. 如果节点需要依赖其他资源，例如图片、 CSS 、视频等，调用资源加载器来加载它们，但是它们是异步的，不会阻碍当前 DOM 树的继续创建；如果是 JavascriPt 资源 URL （没有标记异步方式），则需要停止当前 DOM 树的创建，直到 Javascript 的资源加载并被 Javascript 引擎执行后才继续 DOM 树的创建。    

在上述的过程中，网页在加载和渲染过程中会发出“ DOMConent ”事件和 DOM 的“ onload ”事件，分别在 DOM 树构建完之后，以及 DOM 树建完并且网页所依赖。
![加载过程对应的参数](http://fex.baidu.com/img/build-performance-monitor-in-7-days/timing.png)
### webkit 资源加载机制     

缓存，有资源池，以URL作为标识，如果URL不一样，即使是同一个资源也认为是不同的。      
资源池使用的机制采用LRU算法。替换其中的资源。       

### Chromium 网络栈

查看 chrome://net-internals     
DNS解析和TCP连接占用大量的时间，所以为了高效地加载页面:

1. 减少链接的重定向。有些网页中使用了大量的重定向，可能还会有很多次重定向， 

这不仅要求浏览器建立多次链接，同时也需要多次DNS解析，这会阻碍DNS预取技术的应用，应该尽量避免。  

2. 利用DNS预取机制。< link ref='dns-prefet'  href ="http://thidnsprefetchexample.com">  
3. 搭建支持SPDY协议的服务器，当然指的是那些需要使用HTTPS协议的站。  
4. 避免错误的链接请求。网页中包含了一些失效的链接，当浏览器试图获取该链接对应的资源的时候，就会占用网络资源。 

### Web Components  

1. Custom elements（自定义元素）:   CustomElementRegistry.define() , Window.customElements  
2. Shadow dom (影子DOM)：Element.attachShadow()，Element.shadowRoot，HTMLTemplateElement， HTMLSlotElement，

DocumentOrShadowRoot     
DOM的子树在网页上不可见       
例如：（video） 
伪类：:host, :host(), :host-context()    
伪元素：::shadow and ::content  
组合器：>>> (formerly /deep/)*  

3. HTML templates（HTML模板）： template 和 slot 元素       

### Javascript 的执行   

Javascript 的执行会阻碍后面节点的创建，也会阻碍后面资源的下载。     
将script 加上 async 标识, 扫描到这个时候会先跳过，等资源都下载完之后执行。      

### CSS 解释器  

1. 盒模型       

外边距，外边框，内边距，内容。      

### 硬件加速的基础           

GPU 绘制3D图形性能特别好。  
如果没有分层，引擎会重绘所有区域。因为GPU计算更新区域更费劲。       
合成层：        
css3D属性，css 透视效果，video，webGL, 
canvas2D, css变化动画，clip, z坐标比自己小的兄弟节点。
减少重绘：  

1. 网页分层计算以减少需要重新计算的布局和绘图。 
2. 使用css 3d 变形和动画技术。        

### javascript 引擎     

闭包: 拥有了许多变量和绑定了这些变量的环境的表达式。 
当执行到哪一条语句的时候，哪些能被使用。使用作用域链来实现闭包，
作用域链由执行环境维护。        

### 安全机制    

1. XSS：执行跨域的javascript脚本 

防御：CSP，使用http消息头来指定网站哪些域的资源能被加载

### 移动Webkit      

在移动系统中，需要更多考虑的是触控和手势事件。  
weinre远程调试  

## web安全深度剖析  

### 理论篇

1. SQL 注入漏洞： 用户输入的数据被SQL解释器执行。       
2. 上传漏洞： 

::: tip
2.1 IIS解析漏洞： IIS6.0 建立*.asp 格式的文件夹，其任意文件都将被IIS当做asp文件解析。     
2.2 apache 解析漏洞： apache 1.x 和 2.x 在解析文件时有一个原则：当碰到不认识的扩展名时，  
将会从后向前解析，直到碰到认识的扩展名为止，如果都不认识，则会暴露其源代码
2.3 PHP CGI 解析漏洞： http：//xx.ss/x.txt/xx.php , x.php 是不存在的，PHP将会向前递归解析，造成解析漏洞。      
防止上传漏洞：      

1. 客户端检测：用javascript检测，在文件未上传时，就对文件进行校验。
2. 服务器检测： mime type，扩展名，检测文件是否嵌入恶意代码。 

:::

3. XSS 跨站脚本漏洞： 攻击者在网页中嵌入客户端脚本，通常是javascript编写的恶意代码。    

::: tip
常见危害：  
盗取用户cookie    
修改网页内容        
网站挂马        
利用网站重定向      
XSS蠕虫     
修复：      
敏感字符过来
HttpOnly: 防止客户端脚本访问   
:::   

4.  CSRF(跨站请求伪造)：建立在浏览器与web服务器的会话中;欺骗用户访问URL;

::: tip 预防

1. 二次确认     
2. token 认证    

:::  

### 实战篇    

1. 与安全性相关的HTTP标头：         
csp设置Content-Security-Policy标头可帮助防止跨站点脚本攻击和其他跨站点注入。    
hidePoweredBy删除X-Powered-By标题。 
hpkp添加了公钥固定标头，以防止伪造证书对中间人的攻击。  
hsts设置Strict-Transport-Security标头，以强制建立与服务器的安全（基于SSL / TLS的HTTP）连接。    
ieNoOpen套X-Download-Options为IE8 +。   
noCache集Cache-Control和Pragma标头可禁用客户端缓存。    
noSniff设置X-Content-Type-Options为防止浏览器通过MIME嗅探远离声明的内容类型的响应。     
frameguard设置X-Frame-Options标题以提供点击劫持保护。       
xssFilter设置X-XSS-Protection为在最新的Web浏览器中启用跨站点脚本（XSS）过滤器。         
2. 确保依赖项安全       
npm audit        
npm install -g snyk         
snyk test          
snyk wizard     
3. Node.js安全清单  
实施速率限制，以防止对身份验证的暴力攻击。一种实现方法是使用StrongLoop Microgateway实施限速策略。另外，您可以使用rate-limiter-flexible之类的包并配置限制。      
使用csurf中间件来防止跨站点请求伪造（CSRF）。       
始终过滤和清除用户输入，以防止跨站点脚本（XSS）和命令注入攻击。     
通过使用参数化查询或准备好的语句来防御SQL注入攻击。     
使用开源sqlmap工具检测您的应用程序中的SQL注入漏洞。     
使用nmap和sslyze工具测试SSL密码，密钥和重新协商的配置以及证书的有效性。     
使用安全正则表达式可确保您的正则表达式不受正则表达式拒绝服务攻击的影响。           


## 深入浅出node.js  
node.js 采用事件驱动，异步编程，为网络服务而设计。      
事件驱动是node.js通过内部单线程高效地维护事件循环队列来实现的。 
没有多线程的资源占用和上下文切换。      

### 单线程

无法利用多核CPU 
错误会引起应用退出  
大量计算占用CPU倒置无法继续调用异步IO（解决：child_process）               

### Node 的模块实现     

在node中引入模块，需要经历3个步骤       

1. 路径分析        
2. 文件定位        
3. 编译执行          

核心模块在node源代码的编译过程中，编译进了二进制执行文件。在node进程启动时，    
部分核心模块就被直接加载进内存中，文件模块则要经历完整过程。   

### 核心模块

核心模块分为c/c++编写和javascript编写     
编译程序需要将所有javascript模块文件编译成c/c++代码，   
node采用v8附带的js2c.py工具

### 非I/O 的异步API     

setTimeout(), setInterval(), setImmediate(), process.nextTick()     
调用setTimeout，setInterval创建的定时器会被插入到定会器观察者内部的 
一个红黑树中。      
process.nextTick 方法比setTimeout 轻量     

### Nodejs基础中间件Connect        

[connect](http://blog.fens.me/nodejs-connect/)  

### 异步API添加过载保护     

bagpipe:        

1. 通过一个队列来控制并发量     
2. 当前活跃的异步调用量小于   
3. 活跃调用到定

### V8垃圾回收机制

V8做一次小的垃圾回收需要50ms以上，做一次非增量的垃圾回收甚至要1s以上。 
查看垃圾回收日志： node --trace_gc -e > gc.log     
GC算法： 标记清除算法和引用计数算法         
标记清除算法(V8)：  
以root（windows对象 ）作为起点，使用深度优先搜索向下遍历所有对象，并在对象的头部做标记。        
未被标记的清除的时候就会被清除掉。它们对应的内存变成碎片。碎片化内存的危害：分块的内存查询效率远低于连续的。    
存储空间的浪费。所以清除后会有合并逻辑。    
引用计数算法：
对象头部记录引用它的对象个数，计算器为0时会立即被回收。     
a⇆b 相互引用，没有第三者引用这两个对象，所以无论通过什么途径均访问不到它们，    
就无法被注销。      

### 内存泄漏排查工具        

1. v8-profiler  
2. node-heapdump    
3. node-mtrace  
4. drace    
5. node-memwatch    

### Buffer

buffer 所占的内存不是由V8分配的，属于堆外内存。     

### ANSI转义码  

::: tip 终端共支持8种（代码0，30-37）不同的颜色,8种背景颜色对应的代码为(40-47）
重置：\u001b[0m 
黑色：\u001b[30m    
红色：\u001b[31m    
绿色：\u001b[32m    
... 
可以使用[ansi-colors](https://www.npmjs.com/package/ansi-colors)依赖修改终端输出颜色           
:::   
```js
const colors = require('ansi-colors');
console.log(colors.red('This is a red string!'));
console.log(colors.green('This is a red string!'));
console.log(colors.cyan('This is a cyan string!'));
console.log(colors.yellow('This is a yellow string!')); 
```
### Chrome V8 基础        
#### 内存机制       
1. 新生代内存   
基本的数据对象都被分配到这里，特点小而频。  
使用Scanvenge算法进行回收。     
当新生代的对象经过多次垃圾回收后依然在内存区的时候，    
就会移动到老生代内存区。    
2. 老生代内存   
保存的对象大多数是生存周期很长的甚至是常驻内存的对象。      
使用的是标记清除和标记整理。    
#### 句柄       
是一个32位无符号整型值（32位系统下）,相当于指针的指针.    
是Windows中各个对象的一个唯一的、固定不变的ID,  
Windows使用句柄来标识诸如窗口、位图、画笔等对象，并通过句柄找到这些对象。       
句柄地址（稳定）->记载着对象在内存中的地址->对象在内存中的地址（不稳定）->实际对象         
v8 使用句柄提供堆内存中js数据对象的一个引用。              


